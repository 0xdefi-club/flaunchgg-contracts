// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package memecoin

import (
	"errors"
	"math/big"
	"strings"

	ethereum "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ = errors.New
	_ = big.NewInt
	_ = strings.NewReader
	_ = ethereum.NotFound
	_ = bind.Bind
	_ = common.Big1
	_ = types.BloomLookup
	_ = event.NewSubscription
	_ = abi.ConvertType
)

// ERC20VotesUpgradeableCheckpoint is an auto generated low-level Go binding around an user-defined struct.
type ERC20VotesUpgradeableCheckpoint struct {
	FromBlock uint32
	Votes     *big.Int
}

// MemecoinMetaData contains all meta data concerning the Memecoin contract.
var MemecoinMetaData = &bind.MetaData{
	ABI: "[{\"type\":\"constructor\",\"inputs\":[],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"CLOCK_MODE\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\",\"internalType\":\"string\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"DOMAIN_SEPARATOR\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\",\"internalType\":\"bytes32\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"allowance\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\",\"internalType\":\"address\"},{\"name\":\"spender\",\"type\":\"address\",\"internalType\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"approve\",\"inputs\":[{\"name\":\"spender\",\"type\":\"address\",\"internalType\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\",\"internalType\":\"bool\"}],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"balanceOf\",\"inputs\":[{\"name\":\"account\",\"type\":\"address\",\"internalType\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"burn\",\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"outputs\":[],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"burnFrom\",\"inputs\":[{\"name\":\"account\",\"type\":\"address\",\"internalType\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"outputs\":[],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"checkpoints\",\"inputs\":[{\"name\":\"account\",\"type\":\"address\",\"internalType\":\"address\"},{\"name\":\"pos\",\"type\":\"uint32\",\"internalType\":\"uint32\"}],\"outputs\":[{\"name\":\"\",\"type\":\"tuple\",\"internalType\":\"structERC20VotesUpgradeable.Checkpoint\",\"components\":[{\"name\":\"fromBlock\",\"type\":\"uint32\",\"internalType\":\"uint32\"},{\"name\":\"votes\",\"type\":\"uint224\",\"internalType\":\"uint224\"}]}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"clock\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint48\",\"internalType\":\"uint48\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"creator\",\"inputs\":[],\"outputs\":[{\"name\":\"creator_\",\"type\":\"address\",\"internalType\":\"address\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"crosschainBurn\",\"inputs\":[{\"name\":\"_from\",\"type\":\"address\",\"internalType\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"outputs\":[],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"crosschainMint\",\"inputs\":[{\"name\":\"_to\",\"type\":\"address\",\"internalType\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"outputs\":[],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"decimals\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint8\",\"internalType\":\"uint8\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"decreaseAllowance\",\"inputs\":[{\"name\":\"spender\",\"type\":\"address\",\"internalType\":\"address\"},{\"name\":\"subtractedValue\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\",\"internalType\":\"bool\"}],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"delegate\",\"inputs\":[{\"name\":\"delegatee\",\"type\":\"address\",\"internalType\":\"address\"}],\"outputs\":[],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"delegateBySig\",\"inputs\":[{\"name\":\"delegatee\",\"type\":\"address\",\"internalType\":\"address\"},{\"name\":\"nonce\",\"type\":\"uint256\",\"internalType\":\"uint256\"},{\"name\":\"expiry\",\"type\":\"uint256\",\"internalType\":\"uint256\"},{\"name\":\"v\",\"type\":\"uint8\",\"internalType\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\",\"internalType\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\",\"internalType\":\"bytes32\"}],\"outputs\":[],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"delegates\",\"inputs\":[{\"name\":\"account\",\"type\":\"address\",\"internalType\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\",\"internalType\":\"address\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"eip712Domain\",\"inputs\":[],\"outputs\":[{\"name\":\"fields\",\"type\":\"bytes1\",\"internalType\":\"bytes1\"},{\"name\":\"name\",\"type\":\"string\",\"internalType\":\"string\"},{\"name\":\"version\",\"type\":\"string\",\"internalType\":\"string\"},{\"name\":\"chainId\",\"type\":\"uint256\",\"internalType\":\"uint256\"},{\"name\":\"verifyingContract\",\"type\":\"address\",\"internalType\":\"address\"},{\"name\":\"salt\",\"type\":\"bytes32\",\"internalType\":\"bytes32\"},{\"name\":\"extensions\",\"type\":\"uint256[]\",\"internalType\":\"uint256[]\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"flaunch\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\",\"internalType\":\"contractFlaunch\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"getPastTotalSupply\",\"inputs\":[{\"name\":\"timepoint\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"getPastVotes\",\"inputs\":[{\"name\":\"account\",\"type\":\"address\",\"internalType\":\"address\"},{\"name\":\"timepoint\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"getVotes\",\"inputs\":[{\"name\":\"account\",\"type\":\"address\",\"internalType\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"increaseAllowance\",\"inputs\":[{\"name\":\"spender\",\"type\":\"address\",\"internalType\":\"address\"},{\"name\":\"addedValue\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\",\"internalType\":\"bool\"}],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"initialize\",\"inputs\":[{\"name\":\"name_\",\"type\":\"string\",\"internalType\":\"string\"},{\"name\":\"symbol_\",\"type\":\"string\",\"internalType\":\"string\"},{\"name\":\"tokenUri_\",\"type\":\"string\",\"internalType\":\"string\"}],\"outputs\":[],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"mint\",\"inputs\":[{\"name\":\"_to\",\"type\":\"address\",\"internalType\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"outputs\":[],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"name\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\",\"internalType\":\"string\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"nonces\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\",\"internalType\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"numCheckpoints\",\"inputs\":[{\"name\":\"account\",\"type\":\"address\",\"internalType\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint32\",\"internalType\":\"uint32\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"permit\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\",\"internalType\":\"address\"},{\"name\":\"spender\",\"type\":\"address\",\"internalType\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\",\"internalType\":\"uint256\"},{\"name\":\"deadline\",\"type\":\"uint256\",\"internalType\":\"uint256\"},{\"name\":\"v\",\"type\":\"uint8\",\"internalType\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\",\"internalType\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\",\"internalType\":\"bytes32\"}],\"outputs\":[],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"setMetadata\",\"inputs\":[{\"name\":\"name_\",\"type\":\"string\",\"internalType\":\"string\"},{\"name\":\"symbol_\",\"type\":\"string\",\"internalType\":\"string\"}],\"outputs\":[],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"supportsInterface\",\"inputs\":[{\"name\":\"_interfaceId\",\"type\":\"bytes4\",\"internalType\":\"bytes4\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\",\"internalType\":\"bool\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"symbol\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\",\"internalType\":\"string\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"tokenURI\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\",\"internalType\":\"string\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"totalSupply\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"transfer\",\"inputs\":[{\"name\":\"to\",\"type\":\"address\",\"internalType\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\",\"internalType\":\"bool\"}],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"transferFrom\",\"inputs\":[{\"name\":\"from\",\"type\":\"address\",\"internalType\":\"address\"},{\"name\":\"to\",\"type\":\"address\",\"internalType\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\",\"internalType\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\",\"internalType\":\"bool\"}],\"stateMutability\":\"nonpayable\"},{\"type\":\"function\",\"name\":\"treasury\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\",\"internalType\":\"addresspayable\"}],\"stateMutability\":\"view\"},{\"type\":\"function\",\"name\":\"version\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\",\"internalType\":\"string\"}],\"stateMutability\":\"view\"},{\"type\":\"event\",\"name\":\"Approval\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\",\"indexed\":true,\"internalType\":\"address\"},{\"name\":\"spender\",\"type\":\"address\",\"indexed\":true,\"internalType\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\",\"indexed\":false,\"internalType\":\"uint256\"}],\"anonymous\":false},{\"type\":\"event\",\"name\":\"CrosschainBurn\",\"inputs\":[{\"name\":\"from\",\"type\":\"address\",\"indexed\":true,\"internalType\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false,\"internalType\":\"uint256\"}],\"anonymous\":false},{\"type\":\"event\",\"name\":\"CrosschainMint\",\"inputs\":[{\"name\":\"to\",\"type\":\"address\",\"indexed\":true,\"internalType\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false,\"internalType\":\"uint256\"}],\"anonymous\":false},{\"type\":\"event\",\"name\":\"DelegateChanged\",\"inputs\":[{\"name\":\"delegator\",\"type\":\"address\",\"indexed\":true,\"internalType\":\"address\"},{\"name\":\"fromDelegate\",\"type\":\"address\",\"indexed\":true,\"internalType\":\"address\"},{\"name\":\"toDelegate\",\"type\":\"address\",\"indexed\":true,\"internalType\":\"address\"}],\"anonymous\":false},{\"type\":\"event\",\"name\":\"DelegateVotesChanged\",\"inputs\":[{\"name\":\"delegate\",\"type\":\"address\",\"indexed\":true,\"internalType\":\"address\"},{\"name\":\"previousBalance\",\"type\":\"uint256\",\"indexed\":false,\"internalType\":\"uint256\"},{\"name\":\"newBalance\",\"type\":\"uint256\",\"indexed\":false,\"internalType\":\"uint256\"}],\"anonymous\":false},{\"type\":\"event\",\"name\":\"EIP712DomainChanged\",\"inputs\":[],\"anonymous\":false},{\"type\":\"event\",\"name\":\"Initialized\",\"inputs\":[{\"name\":\"version\",\"type\":\"uint8\",\"indexed\":false,\"internalType\":\"uint8\"}],\"anonymous\":false},{\"type\":\"event\",\"name\":\"MetadataUpdated\",\"inputs\":[{\"name\":\"_name\",\"type\":\"string\",\"indexed\":false,\"internalType\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\",\"indexed\":false,\"internalType\":\"string\"}],\"anonymous\":false},{\"type\":\"event\",\"name\":\"Transfer\",\"inputs\":[{\"name\":\"from\",\"type\":\"address\",\"indexed\":true,\"internalType\":\"address\"},{\"name\":\"to\",\"type\":\"address\",\"indexed\":true,\"internalType\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\",\"indexed\":false,\"internalType\":\"uint256\"}],\"anonymous\":false},{\"type\":\"error\",\"name\":\"CallerNotFlaunch\",\"inputs\":[]},{\"type\":\"error\",\"name\":\"MintAddressIsZero\",\"inputs\":[]},{\"type\":\"error\",\"name\":\"Permit2AllowanceIsFixedAtInfinity\",\"inputs\":[]},{\"type\":\"error\",\"name\":\"Unauthorized\",\"inputs\":[]}]",
	Bin: "0x6080604052348015600e575f5ffd5b5060156019565b60d3565b5f54610100900460ff161560835760405162461bcd60e51b815260206004820152602760248201527f496e697469616c697a61626c653a20636f6e747261637420697320696e697469604482015266616c697a696e6760c81b606482015260840160405180910390fd5b5f5460ff9081161460d1575f805460ff191660ff9081179091556040519081527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b565b612e59806100e05f395ff3fe608060405234801561000f575f5ffd5b50600436106101c0575f3560e01c806301ffc9a7146101c457806302d05d3f146101ec57806306fdde0314610201578063095ea7b31461021657806318160ddd1461022957806318bf50771461023b57806323b872dd146102505780632b8c49e314610263578063313ce567146102765780633644e51514610285578063395093511461028d5780633a46b1a8146102a05780633c130d90146102b357806340c10f19146102bb57806342966c68146102ce5780634bf5d7e9146102e157806351335b50146102e957806354fd4d50146102fc578063587cde1e146103245780635c19a95c1461033757806361d027b31461034a5780636fcfff451461035257806370a082311461037a57806379cc67901461038d5780637ecebe00146103a057806384b0196e146103b357806387211ceb146103ce5780638e539e8c146103e257806391ddadf4146103f557806395d89b41146104145780639ab24eb01461041c578063a457c2d71461042f578063a6487c5314610442578063a9059cbb14610455578063c3cda52014610468578063d505accf1461047b578063dd62ed3e1461048e578063f1127ed8146104a1575b5f5ffd5b6101d76101d236600461259b565b6104de565b60405190151581526020015b60405180910390f35b6101f4610593565b6040516101e391906125c2565b61020961067a565b6040516101e39190612604565b6101d761022436600461262a565b61070a565b6035545b6040519081526020016101e3565b61024e61024936600461262a565b610762565b005b6101d761025e366004612654565b6107d9565b61024e61027136600461262a565b6107fc565b604051601281526020016101e3565b61022d610867565b6101d761029b36600461262a565b610875565b61022d6102ae36600461262a565b6108a0565b6102096108f9565b61024e6102c936600461262a565b610986565b61024e6102dc366004612692565b6109e7565b6102096109f4565b61024e6102f73660046126ed565b610a8c565b60408051808201909152600c81526b312e302e302d626574612e3560a01b6020820152610209565b6101f4610332366004612757565b610b15565b61024e610345366004612757565b610b32565b6101f4610b3c565b610365610360366004612757565b610c23565b60405163ffffffff90911681526020016101e3565b61022d610388366004612757565b610c44565b61024e61039b36600461262a565b610c5e565b61022d6103ae366004612757565b610c73565b6103bb610c90565b6040516101e39796959493929190612772565b610101546101f4906001600160a01b031681565b61022d6103f0366004612692565b610d29565b6103fd610d63565b60405165ffffffffffff90911681526020016101e3565b610209610d6d565b61022d61042a366004612757565b610d7c565b6101d761043d36600461262a565b610df8565b61024e610450366004612808565b610e72565b6101d761046336600461262a565b61106e565b61024e6104763660046128b9565b61107b565b61024e61048936600461290f565b6111a3565b61022d61049c366004612979565b611304565b6104b46104af3660046129b0565b611357565b60408051825163ffffffff1681526020928301516001600160e01b031692810192909252016101e3565b5f6001600160e01b031982166336372b0760e01b148061050e57506001600160e01b031982166336372b0760e01b145b8061052957506001600160e01b03198216634ec7fbed60e11b145b8061053c57506001600160e01b03198216155b8061055757506001600160e01b03198216630cccc66560e21b145b8061057257506001600160e01b031982166301ffc9a760e01b145b8061058d57506001600160e01b03198216631a21778960e31b145b92915050565b61010154604051631f28c5c960e21b81525f9182916001600160a01b0390911690637ca31724906105c89030906004016125c2565b602060405180830381865afa1580156105e3573d5f5f3e3d5ffd5b505050506040513d601f19601f8201168201806040525081019061060791906129e4565b610101546040516331a9108f60e11b8152600481018390529192506001600160a01b031690636352211e90602401602060405180830381865afa92505050801561066e575060408051601f3d908101601f1916820190925261066b918101906129fb565b60015b156106765791505b5090565b606060fe805461068990612a16565b80601f01602080910402602001604051908101604052809291908181526020018280546106b590612a16565b80156107005780601f106106d757610100808354040283529160200191610700565b820191905f5260205f20905b8154815290600101906020018083116106e357829003601f168201915b5050505050905090565b5f6001600160a01b0383166e22d473030f116ddee9f6b43ac78ba314801561073357505f198214155b1561075157604051631fb429cd60e11b815260040160405180910390fd5b61075b83836113d7565b9392505050565b336028602160991b0114610788576040516282b42960e81b815260040160405180910390fd5b61079282826113e4565b816001600160a01b03167f7ca16db12dad0e1c536f8062fd9e2e4fbb3d1a503b59df12a0cfa9f96abf1c59826040516107cd91815260200190565b60405180910390a25050565b5f336107e68582856113ee565b6107f1858585611466565b506001949350505050565b336028602160991b0114610822576040516282b42960e81b815260040160405180910390fd5b61082c8282611602565b816001600160a01b03167f017c33ab728c93e2be949ec7e4a35b76d607957c5fac4253f5d623b4a3b13036826040516107cd91815260200190565b5f61087061160c565b905090565b5f336108968185856108878383611304565b6108919190612a5c565b611615565b5060019392505050565b5f6108a9610d63565b65ffffffffffff1682106108d85760405162461bcd60e51b81526004016108cf90612a6f565b60405180910390fd5b6001600160a01b0383165f90815260cd6020526040902061075b9083611738565b610100805461090790612a16565b80601f016020809104026020016040519081016040528092919081815260200182805461093390612a16565b801561097e5780601f106109555761010080835404028352916020019161097e565b820191905f5260205f20905b81548152906001019060200180831161096157829003601f168201915b505050505081565b610101546001600160a01b031633146109b25760405163c66bfcc360e01b815260040160405180910390fd5b6001600160a01b0382166109d957604051636462dae160e01b815260040160405180910390fd5b6109e382826113e4565b5050565b6109f13382611602565b50565b6060436109ff610d63565b65ffffffffffff1614610a545760405162461bcd60e51b815260206004820152601d60248201527f4552433230566f7465733a2062726f6b656e20636c6f636b206d6f646500000060448201526064016108cf565b5060408051808201909152601d81527f6d6f64653d626c6f636b6e756d6265722666726f6d3d64656661756c74000000602082015290565b610101546001600160a01b03163314610ab85760405163c66bfcc360e01b815260040160405180910390fd5b60fe610ac5848683612b15565b5060ff610ad3828483612b15565b507f30f5c4b652f95e2a697bda3258896c421eee4f29adce8fe38060f47f7aed91ad60fe60ff604051610b07929190612c48565b60405180910390a150505050565b6001600160a01b039081165f90815260cc60205260409020541690565b6109f13382611814565b61010154604051631f28c5c960e21b81525f9182916001600160a01b0390911690637ca3172490610b719030906004016125c2565b602060405180830381865afa158015610b8c573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610bb091906129e4565b61010154604051630f38f95560e41b8152600481018390529192506001600160a01b03169063f38f955090602401602060405180830381865afa158015610bf9573d5f5f3e3d5ffd5b505050506040513d601f19601f82011682018060405250810190610c1d91906129fb565b91505090565b6001600160a01b0381165f90815260cd602052604081205461058d90611891565b6001600160a01b03165f9081526033602052604090205490565b610c698233836113ee565b6109e38282611602565b6001600160a01b0381165f9081526099602052604081205461058d565b5f6060805f5f5f60606065545f5f1b148015610cac5750606654155b610cf05760405162461bcd60e51b81526020600482015260156024820152741152540dcc4c8e88155b9a5b9a5d1a585b1a5e9959605a1b60448201526064016108cf565b610cf86118f5565b610d00611904565b604080515f80825260208201909252600f60f81b9b939a50919850469750309650945092509050565b5f610d32610d63565b65ffffffffffff168210610d585760405162461bcd60e51b81526004016108cf90612a6f565b61058d60ce83611738565b5f61087042611913565b606060ff805461068990612a16565b6001600160a01b0381165f90815260cd60205260408120548015610de6576001600160a01b0383165f90815260cd6020526040902080545f198301908110610dc657610dc6612c75565b5f91825260209091200154600160201b90046001600160e01b0316610de8565b5f5b6001600160e01b03169392505050565b5f3381610e058286611304565b905083811015610e655760405162461bcd60e51b815260206004820152602560248201527f45524332303a2064656372656173656420616c6c6f77616e63652062656c6f77604482015264207a65726f60d81b60648201526084016108cf565b6107f18286868403611615565b5f54610100900460ff1615808015610e9057505f54600160ff909116105b80610ea95750303b158015610ea957505f5460ff166001145b610f0c5760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b60648201526084016108cf565b5f805460ff191660011790558015610f2d575f805461ff0019166101001790555b60fe610f3a878983612b15565b5060ff610f48858783612b15565b50610100610f57838583612b15565b5061010180546001600160a01b03191633179055604080516020601f8901819004810282018101909252878152610fda9189908990819084018382808284375f9201919091525050604080516020601f8b0181900481028201810190925289815292508991508890819084018382808284375f9201919091525061197992505050565b61101887878080601f0160208091040260200160405190810160405280939291908181526020018383808284375f920191909152506119a992505050565b6110206119f2565b8015611065575f805461ff0019169055604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b50505050505050565b5f33610896818585611466565b834211156110cb5760405162461bcd60e51b815260206004820152601d60248201527f4552433230566f7465733a207369676e6174757265206578706972656400000060448201526064016108cf565b604080517fe48329057bfd03d55e49b547132e39cffd9c1820ad7b9d4c5307691425d15adf60208201526001600160a01b0388169181019190915260608101869052608081018590525f906111449061113c9060a00160405160208183030381529060405280519060200120611a1a565b858585611a46565b905061114f81611a6c565b86146111995760405162461bcd60e51b81526020600482015260196024820152784552433230566f7465733a20696e76616c6964206e6f6e636560381b60448201526064016108cf565b6110658188611814565b834211156111f35760405162461bcd60e51b815260206004820152601d60248201527f45524332305065726d69743a206578706972656420646561646c696e6500000060448201526064016108cf565b5f7f6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c98888886112218c611a6c565b6040805160208101969096526001600160a01b0394851690860152929091166060840152608083015260a082015260c0810186905260e0016040516020818303038152906040528051906020012090505f61127b82611a1a565b90505f61128a82878787611a46565b9050896001600160a01b0316816001600160a01b0316146112ed5760405162461bcd60e51b815260206004820152601e60248201527f45524332305065726d69743a20696e76616c6964207369676e6174757265000060448201526064016108cf565b6112f88a8a8a611615565b50505050505050505050565b5f6e22d473030f116ddee9f6b43ac78ba2196001600160a01b0383160161132d57505f1961058d565b6001600160a01b038084165f9081526034602090815260408083209386168352929052205461075b565b604080518082019091525f80825260208201526001600160a01b0383165f90815260cd60205260409020805463ffffffff841690811061139957611399612c75565b5f9182526020918290206040805180820190915291015463ffffffff81168252600160201b90046001600160e01b0316918101919091529392505050565b5f33610896818585611615565b6109e38282611a93565b5f6113f98484611304565b90505f19811461146057818110156114535760405162461bcd60e51b815260206004820152601d60248201527f45524332303a20696e73756666696369656e7420616c6c6f77616e636500000060448201526064016108cf565b6114608484848403611615565b50505050565b6001600160a01b0383166114ca5760405162461bcd60e51b815260206004820152602560248201527f45524332303a207472616e736665722066726f6d20746865207a65726f206164604482015264647265737360d81b60648201526084016108cf565b6001600160a01b03821661152c5760405162461bcd60e51b815260206004820152602360248201527f45524332303a207472616e7366657220746f20746865207a65726f206164647260448201526265737360e81b60648201526084016108cf565b6001600160a01b0383165f90815260336020526040902054818110156115a35760405162461bcd60e51b815260206004820152602660248201527f45524332303a207472616e7366657220616d6f756e7420657863656564732062604482015265616c616e636560d01b60648201526084016108cf565b6001600160a01b038085165f8181526033602052604080822086860390559286168082529083902080548601905591515f516020612de45f395f51905f52906115ef9086815260200190565b60405180910390a3611460848484611b22565b6109e38282611b64565b5f610870611b7c565b6001600160a01b0383166116775760405162461bcd60e51b8152602060048201526024808201527f45524332303a20617070726f76652066726f6d20746865207a65726f206164646044820152637265737360e01b60648201526084016108cf565b6001600160a01b0382166116d85760405162461bcd60e51b815260206004820152602260248201527f45524332303a20617070726f766520746f20746865207a65726f206164647265604482015261737360f01b60648201526084016108cf565b6001600160a01b038381165f8181526034602090815260408083209487168084529482529182902085905590518481527f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925910160405180910390a3505050565b81545f908181600581111561178d575f61175184611bef565b61175b9085612c89565b9050856117688883611cd3565b5463ffffffff16111561177d5780915061178b565b611788816001612a5c565b92505b505b808210156117d6575f6117a08383611ce0565b9050856117ad8883611cd3565b5463ffffffff1611156117c2578091506117d0565b6117cd816001612a5c565b92505b5061178d565b80156117ff576117e98660018303611cd3565b54600160201b90046001600160e01b0316611801565b5f5b6001600160e01b03169695505050505050565b5f61181e83610b15565b90505f61182a84610c44565b6001600160a01b038581165f81815260cc602052604080822080546001600160a01b031916898616908117909155905194955093928616927f3134e8a2e6d97e929a7e54011ea5485d7d196dd5f0ba4d4ef95803e8e3fc257f9190a4611460828483611cfa565b5f63ffffffff8211156106765760405162461bcd60e51b815260206004820152602660248201527f53616665436173743a2076616c756520646f65736e27742066697420696e203360448201526532206269747360d01b60648201526084016108cf565b60606067805461068990612a16565b60606068805461068990612a16565b5f65ffffffffffff8211156106765760405162461bcd60e51b815260206004820152602660248201527f53616665436173743a2076616c756520646f65736e27742066697420696e203460448201526538206269747360d01b60648201526084016108cf565b5f54610100900460ff1661199f5760405162461bcd60e51b81526004016108cf90612c9c565b6109e38282611e0e565b5f54610100900460ff166119cf5760405162461bcd60e51b81526004016108cf90612c9c565b6109f181604051806040016040528060018152602001603160f81b815250611e4d565b5f54610100900460ff16611a185760405162461bcd60e51b81526004016108cf90612c9c565b565b5f61058d611a2661160c565b8360405161190160f01b8152600281019290925260228201526042902090565b5f5f5f611a5587878787611e9a565b91509150611a6281611f4d565b5095945050505050565b6001600160a01b0381165f9081526099602052604090208054600181018255905b50919050565b611a9d8282612091565b6035546001600160e01b031015611b0f5760405162461bcd60e51b815260206004820152603060248201527f4552433230566f7465733a20746f74616c20737570706c79207269736b73206f60448201526f766572666c6f77696e6720766f74657360801b60648201526084016108cf565b61146060ce6121448361214f565b505050565b611b2d8383836122b8565b6001600160a01b03821615801590611b5557505f611b4a83610b15565b6001600160a01b0316145b15611b1d57611b1d8283611814565b611b6e82826122d3565b61146060ce6123f88361214f565b5f7f8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f611ba6612403565b611bae61245b565b60408051602081019490945283019190915260608201524660808201523060a082015260c00160405160208183030381529060405280519060200120905090565b5f815f03611bfe57505f919050565b5f6001611c0a8461248b565b901c6001901b90506001818481611c2357611c23612ce7565b048201901c90506001818481611c3b57611c3b612ce7565b048201901c90506001818481611c5357611c53612ce7565b048201901c90506001818481611c6b57611c6b612ce7565b048201901c90506001818481611c8357611c83612ce7565b048201901c90506001818481611c9b57611c9b612ce7565b048201901c90506001818481611cb357611cb3612ce7565b048201901c905061075b81828581611ccd57611ccd612ce7565b0461251e565b5f91825260209091200190565b5f611cee6002848418612cfb565b61075b90848416612a5c565b816001600160a01b0316836001600160a01b031614158015611d1b57505f81115b15611b1d576001600160a01b03831615611d95576001600160a01b0383165f90815260cd602052604081208190611d55906123f88561214f565b91509150846001600160a01b03165f516020612e045f395f51905f528383604051611d8a929190918252602082015260400190565b60405180910390a250505b6001600160a01b03821615611b1d576001600160a01b0382165f90815260cd602052604081208190611dca906121448561214f565b91509150836001600160a01b03165f516020612e045f395f51905f528383604051611dff929190918252602082015260400190565b60405180910390a25050505050565b5f54610100900460ff16611e345760405162461bcd60e51b81526004016108cf90612c9c565b6036611e408382612d1a565b506037611b1d8282612d1a565b5f54610100900460ff16611e735760405162461bcd60e51b81526004016108cf90612c9c565b6067611e7f8382612d1a565b506068611e8c8282612d1a565b50505f606581905560665550565b5f806fa2a8918ca85bafe22016d0b997e4df60600160ff1b03831115611ec557505f90506003611f44565b604080515f8082526020820180845289905260ff881692820192909252606081018690526080810185905260019060a0016020604051602081039080840390855afa158015611f16573d5f5f3e3d5ffd5b5050604051601f1901519150506001600160a01b038116611f3e575f60019250925050611f44565b91505f90505b94509492505050565b5f816004811115611f6057611f60612dcf565b03611f685750565b6001816004811115611f7c57611f7c612dcf565b03611fc45760405162461bcd60e51b815260206004820152601860248201527745434453413a20696e76616c6964207369676e617475726560401b60448201526064016108cf565b6002816004811115611fd857611fd8612dcf565b036120255760405162461bcd60e51b815260206004820152601f60248201527f45434453413a20696e76616c6964207369676e6174757265206c656e6774680060448201526064016108cf565b600381600481111561203957612039612dcf565b036109f15760405162461bcd60e51b815260206004820152602260248201527f45434453413a20696e76616c6964207369676e6174757265202773272076616c604482015261756560f01b60648201526084016108cf565b6001600160a01b0382166120e75760405162461bcd60e51b815260206004820152601f60248201527f45524332303a206d696e7420746f20746865207a65726f20616464726573730060448201526064016108cf565b8060355f8282546120f89190612a5c565b90915550506001600160a01b0382165f818152603360209081526040808320805486019055518481525f516020612de45f395f51905f52910160405180910390a36109e35f8383611b22565b5f61075b8284612a5c565b82545f908190818115612198576121698760018403611cd3565b60408051808201909152905463ffffffff81168252600160201b90046001600160e01b031660208201526121ac565b604080518082019091525f80825260208201525b905080602001516001600160e01b031693506121cc84868863ffffffff16565b92505f821180156121f457506121e0610d63565b65ffffffffffff16815f015163ffffffff16145b156122365761220283612533565b61220f8860018503611cd3565b80546001600160e01b0392909216600160201b0263ffffffff9092169190911790556122ae565b86604051806040016040528061225a61224d610d63565b65ffffffffffff16611891565b63ffffffff16815260200161226e86612533565b6001600160e01b0390811690915282546001810184555f93845260209384902083519490930151909116600160201b0263ffffffff909316929092179101555b5050935093915050565b611b1d6122c484610b15565b6122cd84610b15565b83611cfa565b6001600160a01b0382166123335760405162461bcd60e51b815260206004820152602160248201527f45524332303a206275726e2066726f6d20746865207a65726f206164647265736044820152607360f81b60648201526084016108cf565b6001600160a01b0382165f90815260336020526040902054818110156123a65760405162461bcd60e51b815260206004820152602260248201527f45524332303a206275726e20616d6f756e7420657863656564732062616c616e604482015261636560f01b60648201526084016108cf565b6001600160a01b0383165f8181526033602090815260408083208686039055603580548790039055518581529192915f516020612de45f395f51905f52910160405180910390a3611b1d835f84611b22565b5f61075b8284612c89565b5f5f61240d6118f5565b805190915015612424578051602090910120919050565b60655480156124335792915050565b7fc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a4709250505090565b5f5f612465611904565b80519091501561247c578051602090910120919050565b60665480156124335792915050565b5f80608083901c1561249f57608092831c92015b604083901c156124b157604092831c92015b602083901c156124c357602092831c92015b601083901c156124d557601092831c92015b600883901c156124e757600892831c92015b600483901c156124f957600492831c92015b600283901c1561250b57600292831c92015b600183901c1561058d5760010192915050565b5f81831061252c578161075b565b5090919050565b5f6001600160e01b038211156106765760405162461bcd60e51b815260206004820152602760248201527f53616665436173743a2076616c756520646f65736e27742066697420696e20326044820152663234206269747360c81b60648201526084016108cf565b5f602082840312156125ab575f5ffd5b81356001600160e01b03198116811461075b575f5ffd5b6001600160a01b0391909116815260200190565b5f81518084528060208401602086015e5f602082860101526020601f19601f83011685010191505092915050565b602081525f61075b60208301846125d6565b6001600160a01b03811681146109f1575f5ffd5b5f5f6040838503121561263b575f5ffd5b823561264681612616565b946020939093013593505050565b5f5f5f60608486031215612666575f5ffd5b833561267181612616565b9250602084013561268181612616565b929592945050506040919091013590565b5f602082840312156126a2575f5ffd5b5035919050565b5f5f83601f8401126126b9575f5ffd5b5081356001600160401b038111156126cf575f5ffd5b6020830191508360208285010111156126e6575f5ffd5b9250929050565b5f5f5f5f60408587031215612700575f5ffd5b84356001600160401b03811115612715575f5ffd5b612721878288016126a9565b90955093505060208501356001600160401b0381111561273f575f5ffd5b61274b878288016126a9565b95989497509550505050565b5f60208284031215612767575f5ffd5b813561075b81612616565b60ff60f81b8816815260e060208201525f61279060e08301896125d6565b82810360408401526127a281896125d6565b606084018890526001600160a01b038716608085015260a0840186905283810360c0850152845180825260208087019350909101905f5b818110156127f75783518352602093840193909201916001016127d9565b50909b9a5050505050505050505050565b5f5f5f5f5f5f6060878903121561281d575f5ffd5b86356001600160401b03811115612832575f5ffd5b61283e89828a016126a9565b90975095505060208701356001600160401b0381111561285c575f5ffd5b61286889828a016126a9565b90955093505060408701356001600160401b03811115612886575f5ffd5b61289289828a016126a9565b979a9699509497509295939492505050565b803560ff811681146128b4575f5ffd5b919050565b5f5f5f5f5f5f60c087890312156128ce575f5ffd5b86356128d981612616565b955060208701359450604087013593506128f5606088016128a4565b9598949750929560808101359460a0909101359350915050565b5f5f5f5f5f5f5f60e0888a031215612925575f5ffd5b873561293081612616565b9650602088013561294081612616565b9550604088013594506060880135935061295c608089016128a4565b9699959850939692959460a0840135945060c09093013592915050565b5f5f6040838503121561298a575f5ffd5b823561299581612616565b915060208301356129a581612616565b809150509250929050565b5f5f604083850312156129c1575f5ffd5b82356129cc81612616565b9150602083013563ffffffff811681146129a5575f5ffd5b5f602082840312156129f4575f5ffd5b5051919050565b5f60208284031215612a0b575f5ffd5b815161075b81612616565b600181811c90821680612a2a57607f821691505b602082108103611a8d57634e487b7160e01b5f52602260045260245ffd5b634e487b7160e01b5f52601160045260245ffd5b8082018082111561058d5761058d612a48565b60208082526019908201527804552433230566f7465733a20667574757265206c6f6f6b757603c1b604082015260600190565b634e487b7160e01b5f52604160045260245ffd5b601f821115611b1d57805f5260205f20601f840160051c81016020851015612adb5750805b601f840160051c820191505b81811015612afa575f8155600101612ae7565b5050505050565b5f19600383901b1c191660019190911b1790565b6001600160401b03831115612b2c57612b2c612aa2565b612b4083612b3a8354612a16565b83612ab6565b5f601f841160018114612b6c575f8515612b5a5750838201355b612b648682612b01565b845550612afa565b5f83815260208120601f198716915b82811015612b9b5786850135825560209485019460019092019101612b7b565b5086821015612bb7575f1960f88860031b161c19848701351681555b505060018560011b0183555050505050565b5f8154612bd581612a16565b808552600182168015612bef5760018114612c0b57612c3f565b60ff1983166020870152602082151560051b8701019350612c3f565b845f5260205f205f5b83811015612c365781546020828a010152600182019150602081019050612c14565b87016020019450505b50505092915050565b604081525f612c5a6040830185612bc9565b8281036020840152612c6c8185612bc9565b95945050505050565b634e487b7160e01b5f52603260045260245ffd5b8181038181111561058d5761058d612a48565b6020808252602b908201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960408201526a6e697469616c697a696e6760a81b606082015260800190565b634e487b7160e01b5f52601260045260245ffd5b5f82612d1557634e487b7160e01b5f52601260045260245ffd5b500490565b81516001600160401b03811115612d3357612d33612aa2565b612d4781612d418454612a16565b84612ab6565b6020601f821160018114612d74575f8315612d625750848201515b612d6c8482612b01565b855550612afa565b5f84815260208120601f198516915b82811015612da35787850151825560209485019460019092019101612d83565b5084821015612dc057868401515f19600387901b60f8161c191681555b50505050600190811b01905550565b634e487b7160e01b5f52602160045260245ffdfeddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3efdec2bacdd2f05b59de34da9b523dff8be42e5e38e818c82fdb0bae774387a724a26469706673582212206356b4d03279a6c652160c63f850a8fa360f09f56f9669f865141e6b24073b9764736f6c634300081b0033",
}

// MemecoinABI is the input ABI used to generate the binding from.
// Deprecated: Use MemecoinMetaData.ABI instead.
var MemecoinABI = MemecoinMetaData.ABI

// MemecoinBin is the compiled bytecode used for deploying new contracts.
// Deprecated: Use MemecoinMetaData.Bin instead.
var MemecoinBin = MemecoinMetaData.Bin

// DeployMemecoin deploys a new Ethereum contract, binding an instance of Memecoin to it.
func DeployMemecoin(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *Memecoin, error) {
	parsed, err := MemecoinMetaData.GetAbi()
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	if parsed == nil {
		return common.Address{}, nil, nil, errors.New("GetABI returned nil")
	}

	address, tx, contract, err := bind.DeployContract(auth, *parsed, common.FromHex(MemecoinBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Memecoin{MemecoinCaller: MemecoinCaller{contract: contract}, MemecoinTransactor: MemecoinTransactor{contract: contract}, MemecoinFilterer: MemecoinFilterer{contract: contract}}, nil
}

// Memecoin is an auto generated Go binding around an Ethereum contract.
type Memecoin struct {
	MemecoinCaller     // Read-only binding to the contract
	MemecoinTransactor // Write-only binding to the contract
	MemecoinFilterer   // Log filterer for contract events
}

// MemecoinCaller is an auto generated read-only Go binding around an Ethereum contract.
type MemecoinCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MemecoinTransactor is an auto generated write-only Go binding around an Ethereum contract.
type MemecoinTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MemecoinFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type MemecoinFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// MemecoinSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type MemecoinSession struct {
	Contract     *Memecoin         // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// MemecoinCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type MemecoinCallerSession struct {
	Contract *MemecoinCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts   // Call options to use throughout this session
}

// MemecoinTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type MemecoinTransactorSession struct {
	Contract     *MemecoinTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// MemecoinRaw is an auto generated low-level Go binding around an Ethereum contract.
type MemecoinRaw struct {
	Contract *Memecoin // Generic contract binding to access the raw methods on
}

// MemecoinCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type MemecoinCallerRaw struct {
	Contract *MemecoinCaller // Generic read-only contract binding to access the raw methods on
}

// MemecoinTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type MemecoinTransactorRaw struct {
	Contract *MemecoinTransactor // Generic write-only contract binding to access the raw methods on
}

// NewMemecoin creates a new instance of Memecoin, bound to a specific deployed contract.
func NewMemecoin(address common.Address, backend bind.ContractBackend) (*Memecoin, error) {
	contract, err := bindMemecoin(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Memecoin{MemecoinCaller: MemecoinCaller{contract: contract}, MemecoinTransactor: MemecoinTransactor{contract: contract}, MemecoinFilterer: MemecoinFilterer{contract: contract}}, nil
}

// NewMemecoinCaller creates a new read-only instance of Memecoin, bound to a specific deployed contract.
func NewMemecoinCaller(address common.Address, caller bind.ContractCaller) (*MemecoinCaller, error) {
	contract, err := bindMemecoin(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &MemecoinCaller{contract: contract}, nil
}

// NewMemecoinTransactor creates a new write-only instance of Memecoin, bound to a specific deployed contract.
func NewMemecoinTransactor(address common.Address, transactor bind.ContractTransactor) (*MemecoinTransactor, error) {
	contract, err := bindMemecoin(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &MemecoinTransactor{contract: contract}, nil
}

// NewMemecoinFilterer creates a new log filterer instance of Memecoin, bound to a specific deployed contract.
func NewMemecoinFilterer(address common.Address, filterer bind.ContractFilterer) (*MemecoinFilterer, error) {
	contract, err := bindMemecoin(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &MemecoinFilterer{contract: contract}, nil
}

// bindMemecoin binds a generic wrapper to an already deployed contract.
func bindMemecoin(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := MemecoinMetaData.GetAbi()
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, *parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Memecoin *MemecoinRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Memecoin.Contract.MemecoinCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Memecoin *MemecoinRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Memecoin.Contract.MemecoinTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Memecoin *MemecoinRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Memecoin.Contract.MemecoinTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Memecoin *MemecoinCallerRaw) Call(opts *bind.CallOpts, result *[]interface{}, method string, params ...interface{}) error {
	return _Memecoin.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Memecoin *MemecoinTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Memecoin.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Memecoin *MemecoinTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Memecoin.Contract.contract.Transact(opts, method, params...)
}

// CLOCKMODE is a free data retrieval call binding the contract method 0x4bf5d7e9.
//
// Solidity: function CLOCK_MODE() view returns(string)
func (_Memecoin *MemecoinCaller) CLOCKMODE(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _Memecoin.contract.Call(opts, &out, "CLOCK_MODE")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// CLOCKMODE is a free data retrieval call binding the contract method 0x4bf5d7e9.
//
// Solidity: function CLOCK_MODE() view returns(string)
func (_Memecoin *MemecoinSession) CLOCKMODE() (string, error) {
	return _Memecoin.Contract.CLOCKMODE(&_Memecoin.CallOpts)
}

// CLOCKMODE is a free data retrieval call binding the contract method 0x4bf5d7e9.
//
// Solidity: function CLOCK_MODE() view returns(string)
func (_Memecoin *MemecoinCallerSession) CLOCKMODE() (string, error) {
	return _Memecoin.Contract.CLOCKMODE(&_Memecoin.CallOpts)
}

// DOMAINSEPARATOR is a free data retrieval call binding the contract method 0x3644e515.
//
// Solidity: function DOMAIN_SEPARATOR() view returns(bytes32)
func (_Memecoin *MemecoinCaller) DOMAINSEPARATOR(opts *bind.CallOpts) ([32]byte, error) {
	var out []interface{}
	err := _Memecoin.contract.Call(opts, &out, "DOMAIN_SEPARATOR")

	if err != nil {
		return *new([32]byte), err
	}

	out0 := *abi.ConvertType(out[0], new([32]byte)).(*[32]byte)

	return out0, err

}

// DOMAINSEPARATOR is a free data retrieval call binding the contract method 0x3644e515.
//
// Solidity: function DOMAIN_SEPARATOR() view returns(bytes32)
func (_Memecoin *MemecoinSession) DOMAINSEPARATOR() ([32]byte, error) {
	return _Memecoin.Contract.DOMAINSEPARATOR(&_Memecoin.CallOpts)
}

// DOMAINSEPARATOR is a free data retrieval call binding the contract method 0x3644e515.
//
// Solidity: function DOMAIN_SEPARATOR() view returns(bytes32)
func (_Memecoin *MemecoinCallerSession) DOMAINSEPARATOR() ([32]byte, error) {
	return _Memecoin.Contract.DOMAINSEPARATOR(&_Memecoin.CallOpts)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_Memecoin *MemecoinCaller) Allowance(opts *bind.CallOpts, owner common.Address, spender common.Address) (*big.Int, error) {
	var out []interface{}
	err := _Memecoin.contract.Call(opts, &out, "allowance", owner, spender)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_Memecoin *MemecoinSession) Allowance(owner common.Address, spender common.Address) (*big.Int, error) {
	return _Memecoin.Contract.Allowance(&_Memecoin.CallOpts, owner, spender)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address owner, address spender) view returns(uint256)
func (_Memecoin *MemecoinCallerSession) Allowance(owner common.Address, spender common.Address) (*big.Int, error) {
	return _Memecoin.Contract.Allowance(&_Memecoin.CallOpts, owner, spender)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_Memecoin *MemecoinCaller) BalanceOf(opts *bind.CallOpts, account common.Address) (*big.Int, error) {
	var out []interface{}
	err := _Memecoin.contract.Call(opts, &out, "balanceOf", account)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_Memecoin *MemecoinSession) BalanceOf(account common.Address) (*big.Int, error) {
	return _Memecoin.Contract.BalanceOf(&_Memecoin.CallOpts, account)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address account) view returns(uint256)
func (_Memecoin *MemecoinCallerSession) BalanceOf(account common.Address) (*big.Int, error) {
	return _Memecoin.Contract.BalanceOf(&_Memecoin.CallOpts, account)
}

// Checkpoints is a free data retrieval call binding the contract method 0xf1127ed8.
//
// Solidity: function checkpoints(address account, uint32 pos) view returns((uint32,uint224))
func (_Memecoin *MemecoinCaller) Checkpoints(opts *bind.CallOpts, account common.Address, pos uint32) (ERC20VotesUpgradeableCheckpoint, error) {
	var out []interface{}
	err := _Memecoin.contract.Call(opts, &out, "checkpoints", account, pos)

	if err != nil {
		return *new(ERC20VotesUpgradeableCheckpoint), err
	}

	out0 := *abi.ConvertType(out[0], new(ERC20VotesUpgradeableCheckpoint)).(*ERC20VotesUpgradeableCheckpoint)

	return out0, err

}

// Checkpoints is a free data retrieval call binding the contract method 0xf1127ed8.
//
// Solidity: function checkpoints(address account, uint32 pos) view returns((uint32,uint224))
func (_Memecoin *MemecoinSession) Checkpoints(account common.Address, pos uint32) (ERC20VotesUpgradeableCheckpoint, error) {
	return _Memecoin.Contract.Checkpoints(&_Memecoin.CallOpts, account, pos)
}

// Checkpoints is a free data retrieval call binding the contract method 0xf1127ed8.
//
// Solidity: function checkpoints(address account, uint32 pos) view returns((uint32,uint224))
func (_Memecoin *MemecoinCallerSession) Checkpoints(account common.Address, pos uint32) (ERC20VotesUpgradeableCheckpoint, error) {
	return _Memecoin.Contract.Checkpoints(&_Memecoin.CallOpts, account, pos)
}

// Clock is a free data retrieval call binding the contract method 0x91ddadf4.
//
// Solidity: function clock() view returns(uint48)
func (_Memecoin *MemecoinCaller) Clock(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _Memecoin.contract.Call(opts, &out, "clock")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// Clock is a free data retrieval call binding the contract method 0x91ddadf4.
//
// Solidity: function clock() view returns(uint48)
func (_Memecoin *MemecoinSession) Clock() (*big.Int, error) {
	return _Memecoin.Contract.Clock(&_Memecoin.CallOpts)
}

// Clock is a free data retrieval call binding the contract method 0x91ddadf4.
//
// Solidity: function clock() view returns(uint48)
func (_Memecoin *MemecoinCallerSession) Clock() (*big.Int, error) {
	return _Memecoin.Contract.Clock(&_Memecoin.CallOpts)
}

// Creator is a free data retrieval call binding the contract method 0x02d05d3f.
//
// Solidity: function creator() view returns(address creator_)
func (_Memecoin *MemecoinCaller) Creator(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _Memecoin.contract.Call(opts, &out, "creator")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Creator is a free data retrieval call binding the contract method 0x02d05d3f.
//
// Solidity: function creator() view returns(address creator_)
func (_Memecoin *MemecoinSession) Creator() (common.Address, error) {
	return _Memecoin.Contract.Creator(&_Memecoin.CallOpts)
}

// Creator is a free data retrieval call binding the contract method 0x02d05d3f.
//
// Solidity: function creator() view returns(address creator_)
func (_Memecoin *MemecoinCallerSession) Creator() (common.Address, error) {
	return _Memecoin.Contract.Creator(&_Memecoin.CallOpts)
}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() view returns(uint8)
func (_Memecoin *MemecoinCaller) Decimals(opts *bind.CallOpts) (uint8, error) {
	var out []interface{}
	err := _Memecoin.contract.Call(opts, &out, "decimals")

	if err != nil {
		return *new(uint8), err
	}

	out0 := *abi.ConvertType(out[0], new(uint8)).(*uint8)

	return out0, err

}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() view returns(uint8)
func (_Memecoin *MemecoinSession) Decimals() (uint8, error) {
	return _Memecoin.Contract.Decimals(&_Memecoin.CallOpts)
}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() view returns(uint8)
func (_Memecoin *MemecoinCallerSession) Decimals() (uint8, error) {
	return _Memecoin.Contract.Decimals(&_Memecoin.CallOpts)
}

// Delegates is a free data retrieval call binding the contract method 0x587cde1e.
//
// Solidity: function delegates(address account) view returns(address)
func (_Memecoin *MemecoinCaller) Delegates(opts *bind.CallOpts, account common.Address) (common.Address, error) {
	var out []interface{}
	err := _Memecoin.contract.Call(opts, &out, "delegates", account)

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Delegates is a free data retrieval call binding the contract method 0x587cde1e.
//
// Solidity: function delegates(address account) view returns(address)
func (_Memecoin *MemecoinSession) Delegates(account common.Address) (common.Address, error) {
	return _Memecoin.Contract.Delegates(&_Memecoin.CallOpts, account)
}

// Delegates is a free data retrieval call binding the contract method 0x587cde1e.
//
// Solidity: function delegates(address account) view returns(address)
func (_Memecoin *MemecoinCallerSession) Delegates(account common.Address) (common.Address, error) {
	return _Memecoin.Contract.Delegates(&_Memecoin.CallOpts, account)
}

// Eip712Domain is a free data retrieval call binding the contract method 0x84b0196e.
//
// Solidity: function eip712Domain() view returns(bytes1 fields, string name, string version, uint256 chainId, address verifyingContract, bytes32 salt, uint256[] extensions)
func (_Memecoin *MemecoinCaller) Eip712Domain(opts *bind.CallOpts) (struct {
	Fields            [1]byte
	Name              string
	Version           string
	ChainId           *big.Int
	VerifyingContract common.Address
	Salt              [32]byte
	Extensions        []*big.Int
}, error) {
	var out []interface{}
	err := _Memecoin.contract.Call(opts, &out, "eip712Domain")

	outstruct := new(struct {
		Fields            [1]byte
		Name              string
		Version           string
		ChainId           *big.Int
		VerifyingContract common.Address
		Salt              [32]byte
		Extensions        []*big.Int
	})
	if err != nil {
		return *outstruct, err
	}

	outstruct.Fields = *abi.ConvertType(out[0], new([1]byte)).(*[1]byte)
	outstruct.Name = *abi.ConvertType(out[1], new(string)).(*string)
	outstruct.Version = *abi.ConvertType(out[2], new(string)).(*string)
	outstruct.ChainId = *abi.ConvertType(out[3], new(*big.Int)).(**big.Int)
	outstruct.VerifyingContract = *abi.ConvertType(out[4], new(common.Address)).(*common.Address)
	outstruct.Salt = *abi.ConvertType(out[5], new([32]byte)).(*[32]byte)
	outstruct.Extensions = *abi.ConvertType(out[6], new([]*big.Int)).(*[]*big.Int)

	return *outstruct, err

}

// Eip712Domain is a free data retrieval call binding the contract method 0x84b0196e.
//
// Solidity: function eip712Domain() view returns(bytes1 fields, string name, string version, uint256 chainId, address verifyingContract, bytes32 salt, uint256[] extensions)
func (_Memecoin *MemecoinSession) Eip712Domain() (struct {
	Fields            [1]byte
	Name              string
	Version           string
	ChainId           *big.Int
	VerifyingContract common.Address
	Salt              [32]byte
	Extensions        []*big.Int
}, error) {
	return _Memecoin.Contract.Eip712Domain(&_Memecoin.CallOpts)
}

// Eip712Domain is a free data retrieval call binding the contract method 0x84b0196e.
//
// Solidity: function eip712Domain() view returns(bytes1 fields, string name, string version, uint256 chainId, address verifyingContract, bytes32 salt, uint256[] extensions)
func (_Memecoin *MemecoinCallerSession) Eip712Domain() (struct {
	Fields            [1]byte
	Name              string
	Version           string
	ChainId           *big.Int
	VerifyingContract common.Address
	Salt              [32]byte
	Extensions        []*big.Int
}, error) {
	return _Memecoin.Contract.Eip712Domain(&_Memecoin.CallOpts)
}

// Flaunch is a free data retrieval call binding the contract method 0x87211ceb.
//
// Solidity: function flaunch() view returns(address)
func (_Memecoin *MemecoinCaller) Flaunch(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _Memecoin.contract.Call(opts, &out, "flaunch")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Flaunch is a free data retrieval call binding the contract method 0x87211ceb.
//
// Solidity: function flaunch() view returns(address)
func (_Memecoin *MemecoinSession) Flaunch() (common.Address, error) {
	return _Memecoin.Contract.Flaunch(&_Memecoin.CallOpts)
}

// Flaunch is a free data retrieval call binding the contract method 0x87211ceb.
//
// Solidity: function flaunch() view returns(address)
func (_Memecoin *MemecoinCallerSession) Flaunch() (common.Address, error) {
	return _Memecoin.Contract.Flaunch(&_Memecoin.CallOpts)
}

// GetPastTotalSupply is a free data retrieval call binding the contract method 0x8e539e8c.
//
// Solidity: function getPastTotalSupply(uint256 timepoint) view returns(uint256)
func (_Memecoin *MemecoinCaller) GetPastTotalSupply(opts *bind.CallOpts, timepoint *big.Int) (*big.Int, error) {
	var out []interface{}
	err := _Memecoin.contract.Call(opts, &out, "getPastTotalSupply", timepoint)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetPastTotalSupply is a free data retrieval call binding the contract method 0x8e539e8c.
//
// Solidity: function getPastTotalSupply(uint256 timepoint) view returns(uint256)
func (_Memecoin *MemecoinSession) GetPastTotalSupply(timepoint *big.Int) (*big.Int, error) {
	return _Memecoin.Contract.GetPastTotalSupply(&_Memecoin.CallOpts, timepoint)
}

// GetPastTotalSupply is a free data retrieval call binding the contract method 0x8e539e8c.
//
// Solidity: function getPastTotalSupply(uint256 timepoint) view returns(uint256)
func (_Memecoin *MemecoinCallerSession) GetPastTotalSupply(timepoint *big.Int) (*big.Int, error) {
	return _Memecoin.Contract.GetPastTotalSupply(&_Memecoin.CallOpts, timepoint)
}

// GetPastVotes is a free data retrieval call binding the contract method 0x3a46b1a8.
//
// Solidity: function getPastVotes(address account, uint256 timepoint) view returns(uint256)
func (_Memecoin *MemecoinCaller) GetPastVotes(opts *bind.CallOpts, account common.Address, timepoint *big.Int) (*big.Int, error) {
	var out []interface{}
	err := _Memecoin.contract.Call(opts, &out, "getPastVotes", account, timepoint)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetPastVotes is a free data retrieval call binding the contract method 0x3a46b1a8.
//
// Solidity: function getPastVotes(address account, uint256 timepoint) view returns(uint256)
func (_Memecoin *MemecoinSession) GetPastVotes(account common.Address, timepoint *big.Int) (*big.Int, error) {
	return _Memecoin.Contract.GetPastVotes(&_Memecoin.CallOpts, account, timepoint)
}

// GetPastVotes is a free data retrieval call binding the contract method 0x3a46b1a8.
//
// Solidity: function getPastVotes(address account, uint256 timepoint) view returns(uint256)
func (_Memecoin *MemecoinCallerSession) GetPastVotes(account common.Address, timepoint *big.Int) (*big.Int, error) {
	return _Memecoin.Contract.GetPastVotes(&_Memecoin.CallOpts, account, timepoint)
}

// GetVotes is a free data retrieval call binding the contract method 0x9ab24eb0.
//
// Solidity: function getVotes(address account) view returns(uint256)
func (_Memecoin *MemecoinCaller) GetVotes(opts *bind.CallOpts, account common.Address) (*big.Int, error) {
	var out []interface{}
	err := _Memecoin.contract.Call(opts, &out, "getVotes", account)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// GetVotes is a free data retrieval call binding the contract method 0x9ab24eb0.
//
// Solidity: function getVotes(address account) view returns(uint256)
func (_Memecoin *MemecoinSession) GetVotes(account common.Address) (*big.Int, error) {
	return _Memecoin.Contract.GetVotes(&_Memecoin.CallOpts, account)
}

// GetVotes is a free data retrieval call binding the contract method 0x9ab24eb0.
//
// Solidity: function getVotes(address account) view returns(uint256)
func (_Memecoin *MemecoinCallerSession) GetVotes(account common.Address) (*big.Int, error) {
	return _Memecoin.Contract.GetVotes(&_Memecoin.CallOpts, account)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_Memecoin *MemecoinCaller) Name(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _Memecoin.contract.Call(opts, &out, "name")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_Memecoin *MemecoinSession) Name() (string, error) {
	return _Memecoin.Contract.Name(&_Memecoin.CallOpts)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() view returns(string)
func (_Memecoin *MemecoinCallerSession) Name() (string, error) {
	return _Memecoin.Contract.Name(&_Memecoin.CallOpts)
}

// Nonces is a free data retrieval call binding the contract method 0x7ecebe00.
//
// Solidity: function nonces(address owner) view returns(uint256)
func (_Memecoin *MemecoinCaller) Nonces(opts *bind.CallOpts, owner common.Address) (*big.Int, error) {
	var out []interface{}
	err := _Memecoin.contract.Call(opts, &out, "nonces", owner)

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// Nonces is a free data retrieval call binding the contract method 0x7ecebe00.
//
// Solidity: function nonces(address owner) view returns(uint256)
func (_Memecoin *MemecoinSession) Nonces(owner common.Address) (*big.Int, error) {
	return _Memecoin.Contract.Nonces(&_Memecoin.CallOpts, owner)
}

// Nonces is a free data retrieval call binding the contract method 0x7ecebe00.
//
// Solidity: function nonces(address owner) view returns(uint256)
func (_Memecoin *MemecoinCallerSession) Nonces(owner common.Address) (*big.Int, error) {
	return _Memecoin.Contract.Nonces(&_Memecoin.CallOpts, owner)
}

// NumCheckpoints is a free data retrieval call binding the contract method 0x6fcfff45.
//
// Solidity: function numCheckpoints(address account) view returns(uint32)
func (_Memecoin *MemecoinCaller) NumCheckpoints(opts *bind.CallOpts, account common.Address) (uint32, error) {
	var out []interface{}
	err := _Memecoin.contract.Call(opts, &out, "numCheckpoints", account)

	if err != nil {
		return *new(uint32), err
	}

	out0 := *abi.ConvertType(out[0], new(uint32)).(*uint32)

	return out0, err

}

// NumCheckpoints is a free data retrieval call binding the contract method 0x6fcfff45.
//
// Solidity: function numCheckpoints(address account) view returns(uint32)
func (_Memecoin *MemecoinSession) NumCheckpoints(account common.Address) (uint32, error) {
	return _Memecoin.Contract.NumCheckpoints(&_Memecoin.CallOpts, account)
}

// NumCheckpoints is a free data retrieval call binding the contract method 0x6fcfff45.
//
// Solidity: function numCheckpoints(address account) view returns(uint32)
func (_Memecoin *MemecoinCallerSession) NumCheckpoints(account common.Address) (uint32, error) {
	return _Memecoin.Contract.NumCheckpoints(&_Memecoin.CallOpts, account)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 _interfaceId) view returns(bool)
func (_Memecoin *MemecoinCaller) SupportsInterface(opts *bind.CallOpts, _interfaceId [4]byte) (bool, error) {
	var out []interface{}
	err := _Memecoin.contract.Call(opts, &out, "supportsInterface", _interfaceId)

	if err != nil {
		return *new(bool), err
	}

	out0 := *abi.ConvertType(out[0], new(bool)).(*bool)

	return out0, err

}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 _interfaceId) view returns(bool)
func (_Memecoin *MemecoinSession) SupportsInterface(_interfaceId [4]byte) (bool, error) {
	return _Memecoin.Contract.SupportsInterface(&_Memecoin.CallOpts, _interfaceId)
}

// SupportsInterface is a free data retrieval call binding the contract method 0x01ffc9a7.
//
// Solidity: function supportsInterface(bytes4 _interfaceId) view returns(bool)
func (_Memecoin *MemecoinCallerSession) SupportsInterface(_interfaceId [4]byte) (bool, error) {
	return _Memecoin.Contract.SupportsInterface(&_Memecoin.CallOpts, _interfaceId)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_Memecoin *MemecoinCaller) Symbol(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _Memecoin.contract.Call(opts, &out, "symbol")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_Memecoin *MemecoinSession) Symbol() (string, error) {
	return _Memecoin.Contract.Symbol(&_Memecoin.CallOpts)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() view returns(string)
func (_Memecoin *MemecoinCallerSession) Symbol() (string, error) {
	return _Memecoin.Contract.Symbol(&_Memecoin.CallOpts)
}

// TokenURI is a free data retrieval call binding the contract method 0x3c130d90.
//
// Solidity: function tokenURI() view returns(string)
func (_Memecoin *MemecoinCaller) TokenURI(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _Memecoin.contract.Call(opts, &out, "tokenURI")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// TokenURI is a free data retrieval call binding the contract method 0x3c130d90.
//
// Solidity: function tokenURI() view returns(string)
func (_Memecoin *MemecoinSession) TokenURI() (string, error) {
	return _Memecoin.Contract.TokenURI(&_Memecoin.CallOpts)
}

// TokenURI is a free data retrieval call binding the contract method 0x3c130d90.
//
// Solidity: function tokenURI() view returns(string)
func (_Memecoin *MemecoinCallerSession) TokenURI() (string, error) {
	return _Memecoin.Contract.TokenURI(&_Memecoin.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_Memecoin *MemecoinCaller) TotalSupply(opts *bind.CallOpts) (*big.Int, error) {
	var out []interface{}
	err := _Memecoin.contract.Call(opts, &out, "totalSupply")

	if err != nil {
		return *new(*big.Int), err
	}

	out0 := *abi.ConvertType(out[0], new(*big.Int)).(**big.Int)

	return out0, err

}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_Memecoin *MemecoinSession) TotalSupply() (*big.Int, error) {
	return _Memecoin.Contract.TotalSupply(&_Memecoin.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() view returns(uint256)
func (_Memecoin *MemecoinCallerSession) TotalSupply() (*big.Int, error) {
	return _Memecoin.Contract.TotalSupply(&_Memecoin.CallOpts)
}

// Treasury is a free data retrieval call binding the contract method 0x61d027b3.
//
// Solidity: function treasury() view returns(address)
func (_Memecoin *MemecoinCaller) Treasury(opts *bind.CallOpts) (common.Address, error) {
	var out []interface{}
	err := _Memecoin.contract.Call(opts, &out, "treasury")

	if err != nil {
		return *new(common.Address), err
	}

	out0 := *abi.ConvertType(out[0], new(common.Address)).(*common.Address)

	return out0, err

}

// Treasury is a free data retrieval call binding the contract method 0x61d027b3.
//
// Solidity: function treasury() view returns(address)
func (_Memecoin *MemecoinSession) Treasury() (common.Address, error) {
	return _Memecoin.Contract.Treasury(&_Memecoin.CallOpts)
}

// Treasury is a free data retrieval call binding the contract method 0x61d027b3.
//
// Solidity: function treasury() view returns(address)
func (_Memecoin *MemecoinCallerSession) Treasury() (common.Address, error) {
	return _Memecoin.Contract.Treasury(&_Memecoin.CallOpts)
}

// Version is a free data retrieval call binding the contract method 0x54fd4d50.
//
// Solidity: function version() view returns(string)
func (_Memecoin *MemecoinCaller) Version(opts *bind.CallOpts) (string, error) {
	var out []interface{}
	err := _Memecoin.contract.Call(opts, &out, "version")

	if err != nil {
		return *new(string), err
	}

	out0 := *abi.ConvertType(out[0], new(string)).(*string)

	return out0, err

}

// Version is a free data retrieval call binding the contract method 0x54fd4d50.
//
// Solidity: function version() view returns(string)
func (_Memecoin *MemecoinSession) Version() (string, error) {
	return _Memecoin.Contract.Version(&_Memecoin.CallOpts)
}

// Version is a free data retrieval call binding the contract method 0x54fd4d50.
//
// Solidity: function version() view returns(string)
func (_Memecoin *MemecoinCallerSession) Version() (string, error) {
	return _Memecoin.Contract.Version(&_Memecoin.CallOpts)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_Memecoin *MemecoinTransactor) Approve(opts *bind.TransactOpts, spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _Memecoin.contract.Transact(opts, "approve", spender, amount)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_Memecoin *MemecoinSession) Approve(spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _Memecoin.Contract.Approve(&_Memecoin.TransactOpts, spender, amount)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address spender, uint256 amount) returns(bool)
func (_Memecoin *MemecoinTransactorSession) Approve(spender common.Address, amount *big.Int) (*types.Transaction, error) {
	return _Memecoin.Contract.Approve(&_Memecoin.TransactOpts, spender, amount)
}

// Burn is a paid mutator transaction binding the contract method 0x42966c68.
//
// Solidity: function burn(uint256 value) returns()
func (_Memecoin *MemecoinTransactor) Burn(opts *bind.TransactOpts, value *big.Int) (*types.Transaction, error) {
	return _Memecoin.contract.Transact(opts, "burn", value)
}

// Burn is a paid mutator transaction binding the contract method 0x42966c68.
//
// Solidity: function burn(uint256 value) returns()
func (_Memecoin *MemecoinSession) Burn(value *big.Int) (*types.Transaction, error) {
	return _Memecoin.Contract.Burn(&_Memecoin.TransactOpts, value)
}

// Burn is a paid mutator transaction binding the contract method 0x42966c68.
//
// Solidity: function burn(uint256 value) returns()
func (_Memecoin *MemecoinTransactorSession) Burn(value *big.Int) (*types.Transaction, error) {
	return _Memecoin.Contract.Burn(&_Memecoin.TransactOpts, value)
}

// BurnFrom is a paid mutator transaction binding the contract method 0x79cc6790.
//
// Solidity: function burnFrom(address account, uint256 value) returns()
func (_Memecoin *MemecoinTransactor) BurnFrom(opts *bind.TransactOpts, account common.Address, value *big.Int) (*types.Transaction, error) {
	return _Memecoin.contract.Transact(opts, "burnFrom", account, value)
}

// BurnFrom is a paid mutator transaction binding the contract method 0x79cc6790.
//
// Solidity: function burnFrom(address account, uint256 value) returns()
func (_Memecoin *MemecoinSession) BurnFrom(account common.Address, value *big.Int) (*types.Transaction, error) {
	return _Memecoin.Contract.BurnFrom(&_Memecoin.TransactOpts, account, value)
}

// BurnFrom is a paid mutator transaction binding the contract method 0x79cc6790.
//
// Solidity: function burnFrom(address account, uint256 value) returns()
func (_Memecoin *MemecoinTransactorSession) BurnFrom(account common.Address, value *big.Int) (*types.Transaction, error) {
	return _Memecoin.Contract.BurnFrom(&_Memecoin.TransactOpts, account, value)
}

// CrosschainBurn is a paid mutator transaction binding the contract method 0x2b8c49e3.
//
// Solidity: function crosschainBurn(address _from, uint256 _amount) returns()
func (_Memecoin *MemecoinTransactor) CrosschainBurn(opts *bind.TransactOpts, _from common.Address, _amount *big.Int) (*types.Transaction, error) {
	return _Memecoin.contract.Transact(opts, "crosschainBurn", _from, _amount)
}

// CrosschainBurn is a paid mutator transaction binding the contract method 0x2b8c49e3.
//
// Solidity: function crosschainBurn(address _from, uint256 _amount) returns()
func (_Memecoin *MemecoinSession) CrosschainBurn(_from common.Address, _amount *big.Int) (*types.Transaction, error) {
	return _Memecoin.Contract.CrosschainBurn(&_Memecoin.TransactOpts, _from, _amount)
}

// CrosschainBurn is a paid mutator transaction binding the contract method 0x2b8c49e3.
//
// Solidity: function crosschainBurn(address _from, uint256 _amount) returns()
func (_Memecoin *MemecoinTransactorSession) CrosschainBurn(_from common.Address, _amount *big.Int) (*types.Transaction, error) {
	return _Memecoin.Contract.CrosschainBurn(&_Memecoin.TransactOpts, _from, _amount)
}

// CrosschainMint is a paid mutator transaction binding the contract method 0x18bf5077.
//
// Solidity: function crosschainMint(address _to, uint256 _amount) returns()
func (_Memecoin *MemecoinTransactor) CrosschainMint(opts *bind.TransactOpts, _to common.Address, _amount *big.Int) (*types.Transaction, error) {
	return _Memecoin.contract.Transact(opts, "crosschainMint", _to, _amount)
}

// CrosschainMint is a paid mutator transaction binding the contract method 0x18bf5077.
//
// Solidity: function crosschainMint(address _to, uint256 _amount) returns()
func (_Memecoin *MemecoinSession) CrosschainMint(_to common.Address, _amount *big.Int) (*types.Transaction, error) {
	return _Memecoin.Contract.CrosschainMint(&_Memecoin.TransactOpts, _to, _amount)
}

// CrosschainMint is a paid mutator transaction binding the contract method 0x18bf5077.
//
// Solidity: function crosschainMint(address _to, uint256 _amount) returns()
func (_Memecoin *MemecoinTransactorSession) CrosschainMint(_to common.Address, _amount *big.Int) (*types.Transaction, error) {
	return _Memecoin.Contract.CrosschainMint(&_Memecoin.TransactOpts, _to, _amount)
}

// DecreaseAllowance is a paid mutator transaction binding the contract method 0xa457c2d7.
//
// Solidity: function decreaseAllowance(address spender, uint256 subtractedValue) returns(bool)
func (_Memecoin *MemecoinTransactor) DecreaseAllowance(opts *bind.TransactOpts, spender common.Address, subtractedValue *big.Int) (*types.Transaction, error) {
	return _Memecoin.contract.Transact(opts, "decreaseAllowance", spender, subtractedValue)
}

// DecreaseAllowance is a paid mutator transaction binding the contract method 0xa457c2d7.
//
// Solidity: function decreaseAllowance(address spender, uint256 subtractedValue) returns(bool)
func (_Memecoin *MemecoinSession) DecreaseAllowance(spender common.Address, subtractedValue *big.Int) (*types.Transaction, error) {
	return _Memecoin.Contract.DecreaseAllowance(&_Memecoin.TransactOpts, spender, subtractedValue)
}

// DecreaseAllowance is a paid mutator transaction binding the contract method 0xa457c2d7.
//
// Solidity: function decreaseAllowance(address spender, uint256 subtractedValue) returns(bool)
func (_Memecoin *MemecoinTransactorSession) DecreaseAllowance(spender common.Address, subtractedValue *big.Int) (*types.Transaction, error) {
	return _Memecoin.Contract.DecreaseAllowance(&_Memecoin.TransactOpts, spender, subtractedValue)
}

// Delegate is a paid mutator transaction binding the contract method 0x5c19a95c.
//
// Solidity: function delegate(address delegatee) returns()
func (_Memecoin *MemecoinTransactor) Delegate(opts *bind.TransactOpts, delegatee common.Address) (*types.Transaction, error) {
	return _Memecoin.contract.Transact(opts, "delegate", delegatee)
}

// Delegate is a paid mutator transaction binding the contract method 0x5c19a95c.
//
// Solidity: function delegate(address delegatee) returns()
func (_Memecoin *MemecoinSession) Delegate(delegatee common.Address) (*types.Transaction, error) {
	return _Memecoin.Contract.Delegate(&_Memecoin.TransactOpts, delegatee)
}

// Delegate is a paid mutator transaction binding the contract method 0x5c19a95c.
//
// Solidity: function delegate(address delegatee) returns()
func (_Memecoin *MemecoinTransactorSession) Delegate(delegatee common.Address) (*types.Transaction, error) {
	return _Memecoin.Contract.Delegate(&_Memecoin.TransactOpts, delegatee)
}

// DelegateBySig is a paid mutator transaction binding the contract method 0xc3cda520.
//
// Solidity: function delegateBySig(address delegatee, uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s) returns()
func (_Memecoin *MemecoinTransactor) DelegateBySig(opts *bind.TransactOpts, delegatee common.Address, nonce *big.Int, expiry *big.Int, v uint8, r [32]byte, s [32]byte) (*types.Transaction, error) {
	return _Memecoin.contract.Transact(opts, "delegateBySig", delegatee, nonce, expiry, v, r, s)
}

// DelegateBySig is a paid mutator transaction binding the contract method 0xc3cda520.
//
// Solidity: function delegateBySig(address delegatee, uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s) returns()
func (_Memecoin *MemecoinSession) DelegateBySig(delegatee common.Address, nonce *big.Int, expiry *big.Int, v uint8, r [32]byte, s [32]byte) (*types.Transaction, error) {
	return _Memecoin.Contract.DelegateBySig(&_Memecoin.TransactOpts, delegatee, nonce, expiry, v, r, s)
}

// DelegateBySig is a paid mutator transaction binding the contract method 0xc3cda520.
//
// Solidity: function delegateBySig(address delegatee, uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s) returns()
func (_Memecoin *MemecoinTransactorSession) DelegateBySig(delegatee common.Address, nonce *big.Int, expiry *big.Int, v uint8, r [32]byte, s [32]byte) (*types.Transaction, error) {
	return _Memecoin.Contract.DelegateBySig(&_Memecoin.TransactOpts, delegatee, nonce, expiry, v, r, s)
}

// IncreaseAllowance is a paid mutator transaction binding the contract method 0x39509351.
//
// Solidity: function increaseAllowance(address spender, uint256 addedValue) returns(bool)
func (_Memecoin *MemecoinTransactor) IncreaseAllowance(opts *bind.TransactOpts, spender common.Address, addedValue *big.Int) (*types.Transaction, error) {
	return _Memecoin.contract.Transact(opts, "increaseAllowance", spender, addedValue)
}

// IncreaseAllowance is a paid mutator transaction binding the contract method 0x39509351.
//
// Solidity: function increaseAllowance(address spender, uint256 addedValue) returns(bool)
func (_Memecoin *MemecoinSession) IncreaseAllowance(spender common.Address, addedValue *big.Int) (*types.Transaction, error) {
	return _Memecoin.Contract.IncreaseAllowance(&_Memecoin.TransactOpts, spender, addedValue)
}

// IncreaseAllowance is a paid mutator transaction binding the contract method 0x39509351.
//
// Solidity: function increaseAllowance(address spender, uint256 addedValue) returns(bool)
func (_Memecoin *MemecoinTransactorSession) IncreaseAllowance(spender common.Address, addedValue *big.Int) (*types.Transaction, error) {
	return _Memecoin.Contract.IncreaseAllowance(&_Memecoin.TransactOpts, spender, addedValue)
}

// Initialize is a paid mutator transaction binding the contract method 0xa6487c53.
//
// Solidity: function initialize(string name_, string symbol_, string tokenUri_) returns()
func (_Memecoin *MemecoinTransactor) Initialize(opts *bind.TransactOpts, name_ string, symbol_ string, tokenUri_ string) (*types.Transaction, error) {
	return _Memecoin.contract.Transact(opts, "initialize", name_, symbol_, tokenUri_)
}

// Initialize is a paid mutator transaction binding the contract method 0xa6487c53.
//
// Solidity: function initialize(string name_, string symbol_, string tokenUri_) returns()
func (_Memecoin *MemecoinSession) Initialize(name_ string, symbol_ string, tokenUri_ string) (*types.Transaction, error) {
	return _Memecoin.Contract.Initialize(&_Memecoin.TransactOpts, name_, symbol_, tokenUri_)
}

// Initialize is a paid mutator transaction binding the contract method 0xa6487c53.
//
// Solidity: function initialize(string name_, string symbol_, string tokenUri_) returns()
func (_Memecoin *MemecoinTransactorSession) Initialize(name_ string, symbol_ string, tokenUri_ string) (*types.Transaction, error) {
	return _Memecoin.Contract.Initialize(&_Memecoin.TransactOpts, name_, symbol_, tokenUri_)
}

// Mint is a paid mutator transaction binding the contract method 0x40c10f19.
//
// Solidity: function mint(address _to, uint256 _amount) returns()
func (_Memecoin *MemecoinTransactor) Mint(opts *bind.TransactOpts, _to common.Address, _amount *big.Int) (*types.Transaction, error) {
	return _Memecoin.contract.Transact(opts, "mint", _to, _amount)
}

// Mint is a paid mutator transaction binding the contract method 0x40c10f19.
//
// Solidity: function mint(address _to, uint256 _amount) returns()
func (_Memecoin *MemecoinSession) Mint(_to common.Address, _amount *big.Int) (*types.Transaction, error) {
	return _Memecoin.Contract.Mint(&_Memecoin.TransactOpts, _to, _amount)
}

// Mint is a paid mutator transaction binding the contract method 0x40c10f19.
//
// Solidity: function mint(address _to, uint256 _amount) returns()
func (_Memecoin *MemecoinTransactorSession) Mint(_to common.Address, _amount *big.Int) (*types.Transaction, error) {
	return _Memecoin.Contract.Mint(&_Memecoin.TransactOpts, _to, _amount)
}

// Permit is a paid mutator transaction binding the contract method 0xd505accf.
//
// Solidity: function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) returns()
func (_Memecoin *MemecoinTransactor) Permit(opts *bind.TransactOpts, owner common.Address, spender common.Address, value *big.Int, deadline *big.Int, v uint8, r [32]byte, s [32]byte) (*types.Transaction, error) {
	return _Memecoin.contract.Transact(opts, "permit", owner, spender, value, deadline, v, r, s)
}

// Permit is a paid mutator transaction binding the contract method 0xd505accf.
//
// Solidity: function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) returns()
func (_Memecoin *MemecoinSession) Permit(owner common.Address, spender common.Address, value *big.Int, deadline *big.Int, v uint8, r [32]byte, s [32]byte) (*types.Transaction, error) {
	return _Memecoin.Contract.Permit(&_Memecoin.TransactOpts, owner, spender, value, deadline, v, r, s)
}

// Permit is a paid mutator transaction binding the contract method 0xd505accf.
//
// Solidity: function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) returns()
func (_Memecoin *MemecoinTransactorSession) Permit(owner common.Address, spender common.Address, value *big.Int, deadline *big.Int, v uint8, r [32]byte, s [32]byte) (*types.Transaction, error) {
	return _Memecoin.Contract.Permit(&_Memecoin.TransactOpts, owner, spender, value, deadline, v, r, s)
}

// SetMetadata is a paid mutator transaction binding the contract method 0x51335b50.
//
// Solidity: function setMetadata(string name_, string symbol_) returns()
func (_Memecoin *MemecoinTransactor) SetMetadata(opts *bind.TransactOpts, name_ string, symbol_ string) (*types.Transaction, error) {
	return _Memecoin.contract.Transact(opts, "setMetadata", name_, symbol_)
}

// SetMetadata is a paid mutator transaction binding the contract method 0x51335b50.
//
// Solidity: function setMetadata(string name_, string symbol_) returns()
func (_Memecoin *MemecoinSession) SetMetadata(name_ string, symbol_ string) (*types.Transaction, error) {
	return _Memecoin.Contract.SetMetadata(&_Memecoin.TransactOpts, name_, symbol_)
}

// SetMetadata is a paid mutator transaction binding the contract method 0x51335b50.
//
// Solidity: function setMetadata(string name_, string symbol_) returns()
func (_Memecoin *MemecoinTransactorSession) SetMetadata(name_ string, symbol_ string) (*types.Transaction, error) {
	return _Memecoin.Contract.SetMetadata(&_Memecoin.TransactOpts, name_, symbol_)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_Memecoin *MemecoinTransactor) Transfer(opts *bind.TransactOpts, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _Memecoin.contract.Transact(opts, "transfer", to, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_Memecoin *MemecoinSession) Transfer(to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _Memecoin.Contract.Transfer(&_Memecoin.TransactOpts, to, amount)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address to, uint256 amount) returns(bool)
func (_Memecoin *MemecoinTransactorSession) Transfer(to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _Memecoin.Contract.Transfer(&_Memecoin.TransactOpts, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_Memecoin *MemecoinTransactor) TransferFrom(opts *bind.TransactOpts, from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _Memecoin.contract.Transact(opts, "transferFrom", from, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_Memecoin *MemecoinSession) TransferFrom(from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _Memecoin.Contract.TransferFrom(&_Memecoin.TransactOpts, from, to, amount)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address from, address to, uint256 amount) returns(bool)
func (_Memecoin *MemecoinTransactorSession) TransferFrom(from common.Address, to common.Address, amount *big.Int) (*types.Transaction, error) {
	return _Memecoin.Contract.TransferFrom(&_Memecoin.TransactOpts, from, to, amount)
}

// MemecoinApprovalIterator is returned from FilterApproval and is used to iterate over the raw logs and unpacked data for Approval events raised by the Memecoin contract.
type MemecoinApprovalIterator struct {
	Event *MemecoinApproval // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *MemecoinApprovalIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(MemecoinApproval)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(MemecoinApproval)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *MemecoinApprovalIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *MemecoinApprovalIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// MemecoinApproval represents a Approval event raised by the Memecoin contract.
type MemecoinApproval struct {
	Owner   common.Address
	Spender common.Address
	Value   *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterApproval is a free log retrieval operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_Memecoin *MemecoinFilterer) FilterApproval(opts *bind.FilterOpts, owner []common.Address, spender []common.Address) (*MemecoinApprovalIterator, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var spenderRule []interface{}
	for _, spenderItem := range spender {
		spenderRule = append(spenderRule, spenderItem)
	}

	logs, sub, err := _Memecoin.contract.FilterLogs(opts, "Approval", ownerRule, spenderRule)
	if err != nil {
		return nil, err
	}
	return &MemecoinApprovalIterator{contract: _Memecoin.contract, event: "Approval", logs: logs, sub: sub}, nil
}

// WatchApproval is a free log subscription operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_Memecoin *MemecoinFilterer) WatchApproval(opts *bind.WatchOpts, sink chan<- *MemecoinApproval, owner []common.Address, spender []common.Address) (event.Subscription, error) {

	var ownerRule []interface{}
	for _, ownerItem := range owner {
		ownerRule = append(ownerRule, ownerItem)
	}
	var spenderRule []interface{}
	for _, spenderItem := range spender {
		spenderRule = append(spenderRule, spenderItem)
	}

	logs, sub, err := _Memecoin.contract.WatchLogs(opts, "Approval", ownerRule, spenderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(MemecoinApproval)
				if err := _Memecoin.contract.UnpackLog(event, "Approval", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApproval is a log parse operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed owner, address indexed spender, uint256 value)
func (_Memecoin *MemecoinFilterer) ParseApproval(log types.Log) (*MemecoinApproval, error) {
	event := new(MemecoinApproval)
	if err := _Memecoin.contract.UnpackLog(event, "Approval", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// MemecoinCrosschainBurnIterator is returned from FilterCrosschainBurn and is used to iterate over the raw logs and unpacked data for CrosschainBurn events raised by the Memecoin contract.
type MemecoinCrosschainBurnIterator struct {
	Event *MemecoinCrosschainBurn // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *MemecoinCrosschainBurnIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(MemecoinCrosschainBurn)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(MemecoinCrosschainBurn)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *MemecoinCrosschainBurnIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *MemecoinCrosschainBurnIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// MemecoinCrosschainBurn represents a CrosschainBurn event raised by the Memecoin contract.
type MemecoinCrosschainBurn struct {
	From   common.Address
	Amount *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterCrosschainBurn is a free log retrieval operation binding the contract event 0x017c33ab728c93e2be949ec7e4a35b76d607957c5fac4253f5d623b4a3b13036.
//
// Solidity: event CrosschainBurn(address indexed from, uint256 amount)
func (_Memecoin *MemecoinFilterer) FilterCrosschainBurn(opts *bind.FilterOpts, from []common.Address) (*MemecoinCrosschainBurnIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}

	logs, sub, err := _Memecoin.contract.FilterLogs(opts, "CrosschainBurn", fromRule)
	if err != nil {
		return nil, err
	}
	return &MemecoinCrosschainBurnIterator{contract: _Memecoin.contract, event: "CrosschainBurn", logs: logs, sub: sub}, nil
}

// WatchCrosschainBurn is a free log subscription operation binding the contract event 0x017c33ab728c93e2be949ec7e4a35b76d607957c5fac4253f5d623b4a3b13036.
//
// Solidity: event CrosschainBurn(address indexed from, uint256 amount)
func (_Memecoin *MemecoinFilterer) WatchCrosschainBurn(opts *bind.WatchOpts, sink chan<- *MemecoinCrosschainBurn, from []common.Address) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}

	logs, sub, err := _Memecoin.contract.WatchLogs(opts, "CrosschainBurn", fromRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(MemecoinCrosschainBurn)
				if err := _Memecoin.contract.UnpackLog(event, "CrosschainBurn", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseCrosschainBurn is a log parse operation binding the contract event 0x017c33ab728c93e2be949ec7e4a35b76d607957c5fac4253f5d623b4a3b13036.
//
// Solidity: event CrosschainBurn(address indexed from, uint256 amount)
func (_Memecoin *MemecoinFilterer) ParseCrosschainBurn(log types.Log) (*MemecoinCrosschainBurn, error) {
	event := new(MemecoinCrosschainBurn)
	if err := _Memecoin.contract.UnpackLog(event, "CrosschainBurn", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// MemecoinCrosschainMintIterator is returned from FilterCrosschainMint and is used to iterate over the raw logs and unpacked data for CrosschainMint events raised by the Memecoin contract.
type MemecoinCrosschainMintIterator struct {
	Event *MemecoinCrosschainMint // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *MemecoinCrosschainMintIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(MemecoinCrosschainMint)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(MemecoinCrosschainMint)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *MemecoinCrosschainMintIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *MemecoinCrosschainMintIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// MemecoinCrosschainMint represents a CrosschainMint event raised by the Memecoin contract.
type MemecoinCrosschainMint struct {
	To     common.Address
	Amount *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterCrosschainMint is a free log retrieval operation binding the contract event 0x7ca16db12dad0e1c536f8062fd9e2e4fbb3d1a503b59df12a0cfa9f96abf1c59.
//
// Solidity: event CrosschainMint(address indexed to, uint256 amount)
func (_Memecoin *MemecoinFilterer) FilterCrosschainMint(opts *bind.FilterOpts, to []common.Address) (*MemecoinCrosschainMintIterator, error) {

	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _Memecoin.contract.FilterLogs(opts, "CrosschainMint", toRule)
	if err != nil {
		return nil, err
	}
	return &MemecoinCrosschainMintIterator{contract: _Memecoin.contract, event: "CrosschainMint", logs: logs, sub: sub}, nil
}

// WatchCrosschainMint is a free log subscription operation binding the contract event 0x7ca16db12dad0e1c536f8062fd9e2e4fbb3d1a503b59df12a0cfa9f96abf1c59.
//
// Solidity: event CrosschainMint(address indexed to, uint256 amount)
func (_Memecoin *MemecoinFilterer) WatchCrosschainMint(opts *bind.WatchOpts, sink chan<- *MemecoinCrosschainMint, to []common.Address) (event.Subscription, error) {

	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _Memecoin.contract.WatchLogs(opts, "CrosschainMint", toRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(MemecoinCrosschainMint)
				if err := _Memecoin.contract.UnpackLog(event, "CrosschainMint", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseCrosschainMint is a log parse operation binding the contract event 0x7ca16db12dad0e1c536f8062fd9e2e4fbb3d1a503b59df12a0cfa9f96abf1c59.
//
// Solidity: event CrosschainMint(address indexed to, uint256 amount)
func (_Memecoin *MemecoinFilterer) ParseCrosschainMint(log types.Log) (*MemecoinCrosschainMint, error) {
	event := new(MemecoinCrosschainMint)
	if err := _Memecoin.contract.UnpackLog(event, "CrosschainMint", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// MemecoinDelegateChangedIterator is returned from FilterDelegateChanged and is used to iterate over the raw logs and unpacked data for DelegateChanged events raised by the Memecoin contract.
type MemecoinDelegateChangedIterator struct {
	Event *MemecoinDelegateChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *MemecoinDelegateChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(MemecoinDelegateChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(MemecoinDelegateChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *MemecoinDelegateChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *MemecoinDelegateChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// MemecoinDelegateChanged represents a DelegateChanged event raised by the Memecoin contract.
type MemecoinDelegateChanged struct {
	Delegator    common.Address
	FromDelegate common.Address
	ToDelegate   common.Address
	Raw          types.Log // Blockchain specific contextual infos
}

// FilterDelegateChanged is a free log retrieval operation binding the contract event 0x3134e8a2e6d97e929a7e54011ea5485d7d196dd5f0ba4d4ef95803e8e3fc257f.
//
// Solidity: event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate)
func (_Memecoin *MemecoinFilterer) FilterDelegateChanged(opts *bind.FilterOpts, delegator []common.Address, fromDelegate []common.Address, toDelegate []common.Address) (*MemecoinDelegateChangedIterator, error) {

	var delegatorRule []interface{}
	for _, delegatorItem := range delegator {
		delegatorRule = append(delegatorRule, delegatorItem)
	}
	var fromDelegateRule []interface{}
	for _, fromDelegateItem := range fromDelegate {
		fromDelegateRule = append(fromDelegateRule, fromDelegateItem)
	}
	var toDelegateRule []interface{}
	for _, toDelegateItem := range toDelegate {
		toDelegateRule = append(toDelegateRule, toDelegateItem)
	}

	logs, sub, err := _Memecoin.contract.FilterLogs(opts, "DelegateChanged", delegatorRule, fromDelegateRule, toDelegateRule)
	if err != nil {
		return nil, err
	}
	return &MemecoinDelegateChangedIterator{contract: _Memecoin.contract, event: "DelegateChanged", logs: logs, sub: sub}, nil
}

// WatchDelegateChanged is a free log subscription operation binding the contract event 0x3134e8a2e6d97e929a7e54011ea5485d7d196dd5f0ba4d4ef95803e8e3fc257f.
//
// Solidity: event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate)
func (_Memecoin *MemecoinFilterer) WatchDelegateChanged(opts *bind.WatchOpts, sink chan<- *MemecoinDelegateChanged, delegator []common.Address, fromDelegate []common.Address, toDelegate []common.Address) (event.Subscription, error) {

	var delegatorRule []interface{}
	for _, delegatorItem := range delegator {
		delegatorRule = append(delegatorRule, delegatorItem)
	}
	var fromDelegateRule []interface{}
	for _, fromDelegateItem := range fromDelegate {
		fromDelegateRule = append(fromDelegateRule, fromDelegateItem)
	}
	var toDelegateRule []interface{}
	for _, toDelegateItem := range toDelegate {
		toDelegateRule = append(toDelegateRule, toDelegateItem)
	}

	logs, sub, err := _Memecoin.contract.WatchLogs(opts, "DelegateChanged", delegatorRule, fromDelegateRule, toDelegateRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(MemecoinDelegateChanged)
				if err := _Memecoin.contract.UnpackLog(event, "DelegateChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDelegateChanged is a log parse operation binding the contract event 0x3134e8a2e6d97e929a7e54011ea5485d7d196dd5f0ba4d4ef95803e8e3fc257f.
//
// Solidity: event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate)
func (_Memecoin *MemecoinFilterer) ParseDelegateChanged(log types.Log) (*MemecoinDelegateChanged, error) {
	event := new(MemecoinDelegateChanged)
	if err := _Memecoin.contract.UnpackLog(event, "DelegateChanged", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// MemecoinDelegateVotesChangedIterator is returned from FilterDelegateVotesChanged and is used to iterate over the raw logs and unpacked data for DelegateVotesChanged events raised by the Memecoin contract.
type MemecoinDelegateVotesChangedIterator struct {
	Event *MemecoinDelegateVotesChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *MemecoinDelegateVotesChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(MemecoinDelegateVotesChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(MemecoinDelegateVotesChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *MemecoinDelegateVotesChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *MemecoinDelegateVotesChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// MemecoinDelegateVotesChanged represents a DelegateVotesChanged event raised by the Memecoin contract.
type MemecoinDelegateVotesChanged struct {
	Delegate        common.Address
	PreviousBalance *big.Int
	NewBalance      *big.Int
	Raw             types.Log // Blockchain specific contextual infos
}

// FilterDelegateVotesChanged is a free log retrieval operation binding the contract event 0xdec2bacdd2f05b59de34da9b523dff8be42e5e38e818c82fdb0bae774387a724.
//
// Solidity: event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance)
func (_Memecoin *MemecoinFilterer) FilterDelegateVotesChanged(opts *bind.FilterOpts, delegate []common.Address) (*MemecoinDelegateVotesChangedIterator, error) {

	var delegateRule []interface{}
	for _, delegateItem := range delegate {
		delegateRule = append(delegateRule, delegateItem)
	}

	logs, sub, err := _Memecoin.contract.FilterLogs(opts, "DelegateVotesChanged", delegateRule)
	if err != nil {
		return nil, err
	}
	return &MemecoinDelegateVotesChangedIterator{contract: _Memecoin.contract, event: "DelegateVotesChanged", logs: logs, sub: sub}, nil
}

// WatchDelegateVotesChanged is a free log subscription operation binding the contract event 0xdec2bacdd2f05b59de34da9b523dff8be42e5e38e818c82fdb0bae774387a724.
//
// Solidity: event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance)
func (_Memecoin *MemecoinFilterer) WatchDelegateVotesChanged(opts *bind.WatchOpts, sink chan<- *MemecoinDelegateVotesChanged, delegate []common.Address) (event.Subscription, error) {

	var delegateRule []interface{}
	for _, delegateItem := range delegate {
		delegateRule = append(delegateRule, delegateItem)
	}

	logs, sub, err := _Memecoin.contract.WatchLogs(opts, "DelegateVotesChanged", delegateRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(MemecoinDelegateVotesChanged)
				if err := _Memecoin.contract.UnpackLog(event, "DelegateVotesChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDelegateVotesChanged is a log parse operation binding the contract event 0xdec2bacdd2f05b59de34da9b523dff8be42e5e38e818c82fdb0bae774387a724.
//
// Solidity: event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance)
func (_Memecoin *MemecoinFilterer) ParseDelegateVotesChanged(log types.Log) (*MemecoinDelegateVotesChanged, error) {
	event := new(MemecoinDelegateVotesChanged)
	if err := _Memecoin.contract.UnpackLog(event, "DelegateVotesChanged", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// MemecoinEIP712DomainChangedIterator is returned from FilterEIP712DomainChanged and is used to iterate over the raw logs and unpacked data for EIP712DomainChanged events raised by the Memecoin contract.
type MemecoinEIP712DomainChangedIterator struct {
	Event *MemecoinEIP712DomainChanged // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *MemecoinEIP712DomainChangedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(MemecoinEIP712DomainChanged)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(MemecoinEIP712DomainChanged)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *MemecoinEIP712DomainChangedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *MemecoinEIP712DomainChangedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// MemecoinEIP712DomainChanged represents a EIP712DomainChanged event raised by the Memecoin contract.
type MemecoinEIP712DomainChanged struct {
	Raw types.Log // Blockchain specific contextual infos
}

// FilterEIP712DomainChanged is a free log retrieval operation binding the contract event 0x0a6387c9ea3628b88a633bb4f3b151770f70085117a15f9bf3787cda53f13d31.
//
// Solidity: event EIP712DomainChanged()
func (_Memecoin *MemecoinFilterer) FilterEIP712DomainChanged(opts *bind.FilterOpts) (*MemecoinEIP712DomainChangedIterator, error) {

	logs, sub, err := _Memecoin.contract.FilterLogs(opts, "EIP712DomainChanged")
	if err != nil {
		return nil, err
	}
	return &MemecoinEIP712DomainChangedIterator{contract: _Memecoin.contract, event: "EIP712DomainChanged", logs: logs, sub: sub}, nil
}

// WatchEIP712DomainChanged is a free log subscription operation binding the contract event 0x0a6387c9ea3628b88a633bb4f3b151770f70085117a15f9bf3787cda53f13d31.
//
// Solidity: event EIP712DomainChanged()
func (_Memecoin *MemecoinFilterer) WatchEIP712DomainChanged(opts *bind.WatchOpts, sink chan<- *MemecoinEIP712DomainChanged) (event.Subscription, error) {

	logs, sub, err := _Memecoin.contract.WatchLogs(opts, "EIP712DomainChanged")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(MemecoinEIP712DomainChanged)
				if err := _Memecoin.contract.UnpackLog(event, "EIP712DomainChanged", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseEIP712DomainChanged is a log parse operation binding the contract event 0x0a6387c9ea3628b88a633bb4f3b151770f70085117a15f9bf3787cda53f13d31.
//
// Solidity: event EIP712DomainChanged()
func (_Memecoin *MemecoinFilterer) ParseEIP712DomainChanged(log types.Log) (*MemecoinEIP712DomainChanged, error) {
	event := new(MemecoinEIP712DomainChanged)
	if err := _Memecoin.contract.UnpackLog(event, "EIP712DomainChanged", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// MemecoinInitializedIterator is returned from FilterInitialized and is used to iterate over the raw logs and unpacked data for Initialized events raised by the Memecoin contract.
type MemecoinInitializedIterator struct {
	Event *MemecoinInitialized // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *MemecoinInitializedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(MemecoinInitialized)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(MemecoinInitialized)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *MemecoinInitializedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *MemecoinInitializedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// MemecoinInitialized represents a Initialized event raised by the Memecoin contract.
type MemecoinInitialized struct {
	Version uint8
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterInitialized is a free log retrieval operation binding the contract event 0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498.
//
// Solidity: event Initialized(uint8 version)
func (_Memecoin *MemecoinFilterer) FilterInitialized(opts *bind.FilterOpts) (*MemecoinInitializedIterator, error) {

	logs, sub, err := _Memecoin.contract.FilterLogs(opts, "Initialized")
	if err != nil {
		return nil, err
	}
	return &MemecoinInitializedIterator{contract: _Memecoin.contract, event: "Initialized", logs: logs, sub: sub}, nil
}

// WatchInitialized is a free log subscription operation binding the contract event 0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498.
//
// Solidity: event Initialized(uint8 version)
func (_Memecoin *MemecoinFilterer) WatchInitialized(opts *bind.WatchOpts, sink chan<- *MemecoinInitialized) (event.Subscription, error) {

	logs, sub, err := _Memecoin.contract.WatchLogs(opts, "Initialized")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(MemecoinInitialized)
				if err := _Memecoin.contract.UnpackLog(event, "Initialized", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseInitialized is a log parse operation binding the contract event 0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498.
//
// Solidity: event Initialized(uint8 version)
func (_Memecoin *MemecoinFilterer) ParseInitialized(log types.Log) (*MemecoinInitialized, error) {
	event := new(MemecoinInitialized)
	if err := _Memecoin.contract.UnpackLog(event, "Initialized", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// MemecoinMetadataUpdatedIterator is returned from FilterMetadataUpdated and is used to iterate over the raw logs and unpacked data for MetadataUpdated events raised by the Memecoin contract.
type MemecoinMetadataUpdatedIterator struct {
	Event *MemecoinMetadataUpdated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *MemecoinMetadataUpdatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(MemecoinMetadataUpdated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(MemecoinMetadataUpdated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *MemecoinMetadataUpdatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *MemecoinMetadataUpdatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// MemecoinMetadataUpdated represents a MetadataUpdated event raised by the Memecoin contract.
type MemecoinMetadataUpdated struct {
	Name   string
	Symbol string
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterMetadataUpdated is a free log retrieval operation binding the contract event 0x30f5c4b652f95e2a697bda3258896c421eee4f29adce8fe38060f47f7aed91ad.
//
// Solidity: event MetadataUpdated(string _name, string _symbol)
func (_Memecoin *MemecoinFilterer) FilterMetadataUpdated(opts *bind.FilterOpts) (*MemecoinMetadataUpdatedIterator, error) {

	logs, sub, err := _Memecoin.contract.FilterLogs(opts, "MetadataUpdated")
	if err != nil {
		return nil, err
	}
	return &MemecoinMetadataUpdatedIterator{contract: _Memecoin.contract, event: "MetadataUpdated", logs: logs, sub: sub}, nil
}

// WatchMetadataUpdated is a free log subscription operation binding the contract event 0x30f5c4b652f95e2a697bda3258896c421eee4f29adce8fe38060f47f7aed91ad.
//
// Solidity: event MetadataUpdated(string _name, string _symbol)
func (_Memecoin *MemecoinFilterer) WatchMetadataUpdated(opts *bind.WatchOpts, sink chan<- *MemecoinMetadataUpdated) (event.Subscription, error) {

	logs, sub, err := _Memecoin.contract.WatchLogs(opts, "MetadataUpdated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(MemecoinMetadataUpdated)
				if err := _Memecoin.contract.UnpackLog(event, "MetadataUpdated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseMetadataUpdated is a log parse operation binding the contract event 0x30f5c4b652f95e2a697bda3258896c421eee4f29adce8fe38060f47f7aed91ad.
//
// Solidity: event MetadataUpdated(string _name, string _symbol)
func (_Memecoin *MemecoinFilterer) ParseMetadataUpdated(log types.Log) (*MemecoinMetadataUpdated, error) {
	event := new(MemecoinMetadataUpdated)
	if err := _Memecoin.contract.UnpackLog(event, "MetadataUpdated", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}

// MemecoinTransferIterator is returned from FilterTransfer and is used to iterate over the raw logs and unpacked data for Transfer events raised by the Memecoin contract.
type MemecoinTransferIterator struct {
	Event *MemecoinTransfer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *MemecoinTransferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(MemecoinTransfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(MemecoinTransfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *MemecoinTransferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *MemecoinTransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// MemecoinTransfer represents a Transfer event raised by the Memecoin contract.
type MemecoinTransfer struct {
	From  common.Address
	To    common.Address
	Value *big.Int
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterTransfer is a free log retrieval operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_Memecoin *MemecoinFilterer) FilterTransfer(opts *bind.FilterOpts, from []common.Address, to []common.Address) (*MemecoinTransferIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _Memecoin.contract.FilterLogs(opts, "Transfer", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return &MemecoinTransferIterator{contract: _Memecoin.contract, event: "Transfer", logs: logs, sub: sub}, nil
}

// WatchTransfer is a free log subscription operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_Memecoin *MemecoinFilterer) WatchTransfer(opts *bind.WatchOpts, sink chan<- *MemecoinTransfer, from []common.Address, to []common.Address) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _Memecoin.contract.WatchLogs(opts, "Transfer", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(MemecoinTransfer)
				if err := _Memecoin.contract.UnpackLog(event, "Transfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransfer is a log parse operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_Memecoin *MemecoinFilterer) ParseTransfer(log types.Log) (*MemecoinTransfer, error) {
	event := new(MemecoinTransfer)
	if err := _Memecoin.contract.UnpackLog(event, "Transfer", log); err != nil {
		return nil, err
	}
	event.Raw = log
	return event, nil
}
